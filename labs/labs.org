* Lab 0: Workflow and Python Basics
  - Unlock tests: ~python ok -q testname -u~
  - Run tests: ~python ok~
  - Show all tests: ~python ok -v~ 
  - Run .py in an interactive session: ~python -i .py~
  - Run doctests in .py: ~python -m doctest .py~ 
* Lab 1: Function and Control
** Topics
*** Functions
**** ~return~ and ~print~  
     - ~return~: When Python executes a *return statement*, the function *terminates immediately*. If Python reaches the end of the function body *without executing a return statement*, it will *automatically return None*.
     - ~print~: When Python evaluates a *print expression*, the function does *not terminate immediately*.
     
     #+begin_src python :results output
       def what_prints():
           print('Hello World!')
           return 'Exiting this function.'
           print('61A is awesome!')

       print(what_prints())
     #+end_src 

     #+RESULTS:
     : Hello World!
     : Exiting this function.
 
*** Control
**** Boolean Operators

     | booblean operators | priority |
     | ~not~              | highest  |
     | ~and~              | medium   |
     | ~or~               | lowest   |

     For *A is True* and *B is False*

     | expression       | return  |
     | ~A and C~        | ~C~     |
     | ~A or C~         | ~A~     |
     | ~B and C~        | ~B~     |
     | ~B or C~         | ~C~     |
     | ~Error and/or C~ | ~Error~ |
     
     ~and~ and ~or~ *don't always return booleans* when using values other than ~True and False~: A,B,C above, they can be booleans, numbers, strings and even ~Error~.
     
*** Error Messages

    | Error Types         | Descriptions                              |
    | ~SyntaxError~       | Contained improper syntax                 |
    | ~IndentationError~  | Contained improper indentation            |
    | ~TypeError~         | Attempted operation on incompatible types |
    | ~ZeroDivisionError~ | Attempted division by zero                |

** Required Questions
*** Coding Practice
**** Q4: Sum Digits

     #+begin_src python :results output
       def sum_digits(n):
           """Sum all the digits of n.

           >>> sum_digits(10) # 1 + 0 = 1
           1
           >>> sum_digits(4224) # 4 + 2 + 2 + 4 = 12
           12
           >>> sum_digits(1234567890)
           45
           """
           "*** YOUR CODE HERE ***"
           s = 0
           while n // 10 > 0:
               r = n % 10
               n = (n - r) // 10
               s += r
           return s + n % 10
     #+end_src 

** Optional Questions
*** Q6: Falling Factorial

    #+begin_src python :results output
      def falling(n, k):
          """Compute the falling factorial of n to depth k.

          >>> falling(6, 3)  # 6 * 5 * 4
          120
          >>> falling(4, 0)
          1
          >>> falling(4, 3)  # 4 * 3 * 2
          24
          >>> falling(4, 1)  # 4
          4
          """
          "*** YOUR CODE HERE ***"
          a = n
          f = 1
          while k > 0:
              f = f * a
              k -= 1
              a -= 1
          return f
    #+end_src 

*** Q7: Double Eights

    #+begin_src python :results output
      def double_eights(n):
          """Return true if n has two eights in a row.
          >>> double_eights(8)
          False
          >>> double_eights(88)
          True
          >>> double_eights(2882)
          True
          >>> double_eights(880088)
          True
          >>> double_eights(12345)
          False
          >>> double_eights(80808080)
          False
          """
          "*** YOUR CODE HERE ***"
          while n // 10 > 0:
              if n % 100 == 88:
                  break
              else:
                  n = (n - n % 10) // 10
          if n // 10 == 0:
              return False
          else:
              return True
    #+end_src 

* Lab 2: Higher Order Functions
** Topics
*** Lambda Expressions
    ~lambda <parameters>: <return expression>~. 
**** ~lambda~ vs ~def~   

     |                     | ~lambda~                                                                                       | ~def~                                                                                                          |
     | Type                | /Expression/ that evaluates to a value                                                         | /Statement/ that *alters the env*                                                                              |
     | Result of execution | Creates an *anonymous lambda function* with *no intrinsic* name                                | Creates a *function* with an *intrinsic* name and binds it to that name in the *current env*                   |
     | Effect on the env   | *Evaluating* a ~lambda~ *expression* does *not* create or modify any variables(change the env) | Executing a ~def~ *statement* both creates a *new function* object and binds it to a name in the *current env* |
     
***** Example

      #+begin_src python :results output
        lambda x: x * x #no binding created
        square = lambda x: x * x
        square(4) #calling a lambda function
      #+end_src 

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 21:05:16
      [[file:Lab%202:%20Higher%20Order%20Functions/screenshot_2019-03-31_21-05-16.png]]

***** Two ways of def funcs 

      #+begin_src python :results output
          a = lambda <paras(1)>: lambda <paras(2)>: ... : lambda <paras(n)>: <expression>

          def a(paras(1)):
              def a2(paras(2)):
                  ...
                  def an(paras(n)):
                      return <expression>
                  return a3
              return a2
      #+end_src 
      
      However, in ~lambda~ method func ~a~ points to a *non-intrinsic name* func object, while in ~def~ method func ~a~ points to a func whose *intrinsic name* is ~a~.

** Required Questions 
*** What Would Python Display?
**** Q1: WWPD: Lambda the Free
   
     #+begin_example
       >>> (lambda: 3)()  # Using a lambda expression as an operator in a call exp.
       3
       >>> b = lambda x: lambda: x  # Lambdas can return other lambdas!
       >>> c = b(88)
       >>> c
       Function
       >>> c()
       88

       >>> z = 3
       >>> e = lambda x: lambda y: lambda: x + y + z
       >>> e(0)(1)()
       4
       >>> f = lambda z: x + z
       >>> f(3)
       Error

       >>> higher_order_lambda = lambda f: lambda x: f(x)
       >>> g = lambda x: x * x
       >>> higher_order_lambda(2)(g) # Which argument belongs to which function call?
       Error
       >>> higher_order_lambda(g)(2)
       4
       >>> call_thrice = lambda f: lambda x: f(f(f(x)))
       >>> call_thrice(lambda y: y + 1)(0)
       3
       >>> print_lambda = lambda z: print(z)
       >>> print_lambda
       Function
       >>> one_thousand = print_lambda(1000)
       1000
       >>> one_thousand
       Nothing
     #+end_example

**** Q2: WWPD: Higher Order Functions

     #+begin_example
       >>> def even(f):
       ...     def odd(x):
       ...         if x < 0:
       ...             return f(-x)
       ...         return f(x)
       ...     return odd
       >>> steven = lambda x: x
       >>> stewart = even(steven)
       >>> stewart
       Function
       >>> stewart(61)
       61
       >>> stewart(-4)
       4

       >>> higher_order_lambda = lambda f: lambda x: f(x)
       >>> def cake():
       ...    print('beets')
       ...    def pie():
       ...        print('sweets')
       ...        return 'cake'
       ...    return pie
       >>> chocolate = cake()
       beets
       >>> chocolate
       Function
       >>> chocolate()
       sweets
       'cake'
       >>> more_chocolate, more_cake = chocolate(), cake
       sweets
       >>> more_chocolate
       'cake'
       >>> def snake(x, y):
       ...    if cake == more_cake:
       ...        return lambda: x + y
       ...    else:
       ...        return x + y
       >>> snake(10, 20)
       Function
       >>> snake(10, 20)()
       30
       >>> cake = 'cake'
       >>> snake(10, 20)
       30
     #+end_example

*** Coding Practice
**** Q3: Lambdas and Currying

     #+begin_src python :results output
       def lambda_curry2(func):
           """
           Returns a Curried version of a two-argument function FUNC.
           >>> from operator import add
           >>> curried_add = lambda_curry2(add)
           >>> add_three = curried_add(3)
           >>> add_three(5)
           8
           """
           "*** YOUR CODE HERE ***"
           return lambda x: lambda y: func(x, y)
     #+end_src 
     
** Optional Questions
*** Environment Diagram Practice
**** Q4: Make Adder

     #+begin_src python :results output
       n = 9
       def make_adder(n):
           return lambda k: k + n
       add_ten = make_adder(n+1)
       result = add_ten(n)
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 22:41:46
     [[file:Lab%202:%20Higher%20Order%20Functions/screenshot_2019-03-31_22-41-46.png]]
 
**** Q5: Lambda the Environment Diagram

     #+begin_src python :results output
       a = lambda x: x * 2 + 1
       def b(b, x):
           return b(x + a(x))

       x = 3
       b(a, x)
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 22:47:46
     [[file:Lab%202:%20Higher%20Order%20Functions/screenshot_2019-03-31_22-47-46.png]]
 
*** More Coding Practice
**** Q6: Composite Identity Function
