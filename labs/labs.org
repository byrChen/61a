#+TAGS: OUTSTANDING(o) QUESTIONS(q)

* Lab 0 Workflow and Python Basics
  - Unlock tests: ~python ok -q testname -u~
  - Run tests: ~python ok~
  - Show all tests: ~python ok -v~ 
  - Run .py in an interactive session: ~python -i .py~
  - Run doctests in .py: ~python -m doctest .py~ 
* Lab 1 Function and Control
** Topics
*** Functions
**** ~return~ and ~print~  
     - ~return~: When Python executes a *return statement*, the function *terminates immediately*. If Python reaches the end of the function body *without executing a return statement*, it will *automatically return None*.
     - ~print~: When Python evaluates a *print expression*, the function does *not terminate immediately*.
     
     #+begin_src python :results output
       def what_prints():
           print('Hello World!')
           return 'Exiting this function.'
           print('61A is awesome!')

       print(what_prints())
     #+end_src 

     #+RESULTS:
     : Hello World!
     : Exiting this function.
 
*** Control
**** Boolean Operators

     | booblean operators | priority |
     | ~not~              | highest  |
     | ~and~              | medium   |
     | ~or~               | lowest   |

     For *A is True* and *B is False*

     | expression       | return  |
     | ~A and C~        | ~C~     |
     | ~A or C~         | ~A~     |
     | ~B and C~        | ~B~     |
     | ~B or C~         | ~C~     |
     | ~Error and/or C~ | ~Error~ |
     
     ~and~ and ~or~ *don't always return booleans* when using values other than ~True and False~: A,B,C above, they can be booleans, numbers, strings and even ~Error~.
     
*** Error Messages

    | Error Types         | Descriptions                              |
    | ~SyntaxError~       | Contained improper syntax                 |
    | ~IndentationError~  | Contained improper indentation            |
    | ~TypeError~         | Attempted operation on incompatible types |
    | ~ZeroDivisionError~ | Attempted division by zero                |

** Required Questions
*** Coding Practice
**** Q4: Sum Digits

     #+begin_src python :results output
       def sum_digits(n):
           """Sum all the digits of n.

           >>> sum_digits(10) # 1 + 0 = 1
           1
           >>> sum_digits(4224) # 4 + 2 + 2 + 4 = 12
           12
           >>> sum_digits(1234567890)
           45
           """
           "*** YOUR CODE HERE ***"
           s = 0
           while n // 10 > 0:
               r = n % 10
               n = (n - r) // 10
               s += r
           return s + n % 10
           "***SOLUTION***"
           total = 0
           while n > 0:
               total, n = total + n % 10, n // 10
           return total
     #+end_src 

** Optional Questions
*** Q6: Falling Factorial

    #+begin_src python :results output
      def falling(n, k):
          """Compute the falling factorial of n to depth k.

          >>> falling(6, 3)  # 6 * 5 * 4
          120
          >>> falling(4, 0)
          1
          >>> falling(4, 3)  # 4 * 3 * 2
          24
          >>> falling(4, 1)  # 4
          4
          """
          "*** YOUR CODE HERE ***"
          a = n
          f = 1
          while k > 0:
              f = f * a
              k -= 1
              a -= 1
          return f
          "***SOLUTION***"
          total, stop = 1, n-k
          while n > stop:
              total, n = total*n, n-1
          return total
    #+end_src 

*** Q7: Double Eights

    #+begin_src python :results output
      def double_eights(n):
          """Return true if n has two eights in a row.
          >>> double_eights(8)
          False
          >>> double_eights(88)
          True
          >>> double_eights(2882)
          True
          >>> double_eights(880088)
          True
          >>> double_eights(12345)
          False
          >>> double_eights(80808080)
          False
          """
          "*** YOUR CODE HERE ***"
          while n // 10 > 0:
              if n % 100 == 88:
                  break
              else:
                  n = (n - n % 10) // 10
          if n // 10 == 0:
              return False
          else:
              return True
          "***SOLUTION***"
          prev_eight = False
          while n > 0:
              last_digit = n % 10
              if last_digit == 8 and prev_eight:
                  return True
              elif last_digit == 8:
                  prev_eight = True
              else:
                  prev_eight = False
              n = n // 10
          return False
    #+end_src 

* Lab 2 Higher Order Functions
** Topics
*** Lambda Expressions
    ~lambda <parameters>: <return expression>~. 
**** ~lambda~ vs ~def~   

     |                     | ~lambda~                                                                                       | ~def~                                                                                                          |
     | Type                | /Expression/ that evaluates to a value                                                         | /Statement/ that *alters the env*                                                                              |
     | Result of execution | Creates an *anonymous lambda function* with *no intrinsic* name                                | Creates a *function* with an *intrinsic* name and binds it to that name in the *current env*                   |
     | Effect on the env   | *Evaluating* a ~lambda~ *expression* does *not* create or modify any variables(change the env) | Executing a ~def~ *statement* both creates a *new function* object and binds it to a name in the *current env* |
     
***** Example

      #+begin_src python :results output
        lambda x: x * x #no binding created
        square = lambda x: x * x
        square(4) #calling a lambda function
      #+end_src 

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 21:05:16
      [[file:Lab%202%20Higher%20Order%20Functions/screenshot_2019-03-31_21-05-16.png]]

***** Two ways of def funcs 

      #+begin_src python :results output
          a = lambda <paras(1)>: lambda <paras(2)>: ... : lambda <paras(n)>: <expression>

          def a(paras(1)):
              def a2(paras(2)):
                  ...
                  def an(paras(n)):
                      return <expression>
                  return a3
              return a2
      #+end_src 
      
      However, in ~lambda~ method func ~a~ points to a *non-intrinsic name* func object, while in ~def~ method func ~a~ points to a func whose *intrinsic name* is ~a~.

** Required Questions 
*** What Would Python Display?
**** Q1: WWPD: Lambda the Free
   
     #+begin_example
       >>> (lambda: 3)()  # Using a lambda expression as an operator in a call exp.
       3
       >>> b = lambda x: lambda: x  # Lambdas can return other lambdas!
       >>> c = b(88)
       >>> c
       Function
       >>> c()
       88

       >>> z = 3
       >>> e = lambda x: lambda y: lambda: x + y + z
       >>> e(0)(1)()
       4
       >>> f = lambda z: x + z
       >>> f(3)
       Error

       >>> higher_order_lambda = lambda f: lambda x: f(x)
       >>> g = lambda x: x * x
       >>> higher_order_lambda(2)(g) # Which argument belongs to which function call?
       Error
       >>> higher_order_lambda(g)(2)
       4
       >>> call_thrice = lambda f: lambda x: f(f(f(x)))
       >>> call_thrice(lambda y: y + 1)(0)
       3
       >>> print_lambda = lambda z: print(z)
       >>> print_lambda
       Function
       >>> one_thousand = print_lambda(1000)
       1000
       >>> one_thousand
       Nothing
     #+end_example

**** Q2: WWPD: Higher Order Functions

     #+begin_example
       >>> def even(f):
       ...     def odd(x):
       ...         if x < 0:
       ...             return f(-x)
       ...         return f(x)
       ...     return odd
       >>> steven = lambda x: x
       >>> stewart = even(steven)
       >>> stewart
       Function
       >>> stewart(61)
       61
       >>> stewart(-4)
       4

       >>> higher_order_lambda = lambda f: lambda x: f(x)
       >>> def cake():
       ...    print('beets')
       ...    def pie():
       ...        print('sweets')
       ...        return 'cake'
       ...    return pie
       >>> chocolate = cake()
       beets
       >>> chocolate
       Function
       >>> chocolate()
       sweets
       'cake'
       >>> more_chocolate, more_cake = chocolate(), cake
       sweets
       >>> more_chocolate
       'cake'
       >>> def snake(x, y):
       ...    if cake == more_cake:
       ...        return lambda: x + y
       ...    else:
       ...        return x + y
       >>> snake(10, 20)
       Function
       >>> snake(10, 20)()
       30
       >>> cake = 'cake'
       >>> snake(10, 20)
       30
     #+end_example

*** Coding Practice
**** Q3: Lambdas and Currying

     #+begin_src python :results output
       def lambda_curry2(func):
           """
           Returns a Curried version of a two-argument function FUNC.
           >>> from operator import add
           >>> curried_add = lambda_curry2(add)
           >>> add_three = curried_add(3)
           >>> add_three(5)
           8
           """
           "*** YOUR CODE HERE ***"
           return lambda x: lambda y: func(x, y)
     #+end_src 
     
** Optional Questions
*** Environment Diagram Practice
**** Q4: Make Adder

     #+begin_src python :results output
       n = 9
       def make_adder(n):
           return lambda k: k + n
       add_ten = make_adder(n+1)
       result = add_ten(n)
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 22:41:46
     [[file:Lab%202%20Higher%20Order%20Functions/screenshot_2019-03-31_22-41-46.png]]
     
     1. ~add_ten~ is evaluated in *Global* while ~lambda k: k + n~ was evaluated in *f1*.
     2. In *Global* ~n=9~ while in *f1* ~n=10~, ~add_ten(n)~ firstly passes(*finds*) ~n=9~ to ~k~ under *Global*, secondly passes(*finds*) ~n=10~ to ~n~ under *f1*, finally returns ~9 + 10~.
     3. ~add_ten(n)~ = ~make_adder(n+1)(n)~.
 
**** Q5: Lambda the Environment Diagram

     #+begin_src python :results output
       a = lambda x: x * 2 + 1
       def b(b, x):
           return b(x + a(x))

       x = 3
       b(a, x)
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 22:47:46
     [[file:Lab%202%20Higher%20Order%20Functions/screenshot_2019-03-31_22-47-46.png]]

     1. A *new frame created* when *calling of a func* finished *passing* (and perhaps *calculating*) *func name* and *args* under *present(or previous) frame* to its *func signature(name and paras)*, then the *body of func* will be executed under this *new frame*. 
     2. Created frame's *parent* frame = the frame where the *called func is evaluated*, not the frame where the *called func is called*.
     3. ~b(a, x)~ firstly passes *func ~b~, args ~a = lambda x: x * 2 + 1~ and ~x=3~ under Global* to *func signature(no need to calculate)*, then *f1* created, *f1's parent=Global* as ~b~ is evaluated under *Global*.
     4. Calling of ~b(x + a(x))~ under *f1* passes *func ~b=a~, args ~x=3~ under f1* and *args ~a = lambda x: x * 2 + 1~ under Global(previous)* to *func signature(need to calculate args ~x + a(x)~)*. ~a(x)~ which *called under f1* passes *args ~x=3~ under f1, func ~a = lambda x: x * 2 + 1~ under Global(previous)* to *func signature(no need to calculate)* and then creat *f2*, *f2's parent is Global, not f1*, as ~a~ is evaluated under *Global(~a~'s parent is Global)*.          
     5. ~b(x + a(x))~ passes *func ~b=a~, args ~x + a(x) = 10~ under f1* and *func ~a = lambda x: x * 2 + 1~ under Global* to *func signature(no need to calculate)*, then *f3* created, *f3's parent=Global* as ~a~ is evaluated under *Global*.
 
*** More Coding Practice
**** Q6: Composite Identity Function                            

**** Q7: Count van Count

     #+begin_src python :results output
       def count_cond(condition):
           """Returns a function with one parameter N that counts all the numbers from
           1 to N that satisfy the two-argument predicate function Condition, where
           the first argument for Condition is N and the second argument is the
           number from 1 to N.

           >>> count_factors = count_cond(lambda n, i: n % i == 0)
           >>> count_factors(2)   # 1, 2
           2
           >>> count_factors(4)   # 1, 2, 4
           3
           >>> count_factors(12)  # 1, 2, 3, 4, 6, 12
           6

           >>> is_prime = lambda n, i: count_factors(i) == 2
           >>> count_primes = count_cond(is_prime)
           >>> count_primes(2)    # 2
           1
           >>> count_primes(3)    # 2, 3
           2
           >>> count_primes(4)    # 2, 3
           2
           >>> count_primes(5)    # 2, 3, 5
           3
           >>> count_primes(20)   # 2, 3, 5, 7, 11, 13, 17, 19
           8
           """
           "*** YOUR CODE HERE ***"
           def a(N):
               i, count = 1, 0
               while i <= N:
                   if condition(N, i):
                       count += 1
                   i += 1
               return  count
           return a
     #+end_src 

     - Func name ~a~ can be ~counter~ 

**** Q8: I Heard You Liked Functions...

     #+begin_src python :results output
       def cycle(f1, f2, f3):
           """Returns a function that is itself a higher-order function.

           >>> def add1(x):
           ...     return x + 1
           >>> def times2(x):
           ...     return x * 2
           >>> def add3(x):
           ...     return x + 3
           >>> my_cycle = cycle(add1, times2, add3)
           >>> identity = my_cycle(0)
           >>> identity(5)
           5
           >>> add_one_then_double = my_cycle(2)
           >>> add_one_then_double(1)
           4
           >>> do_all_functions = my_cycle(3)
           >>> do_all_functions(2)
           9
           >>> do_more_than_a_cycle = my_cycle(4)
           >>> do_more_than_a_cycle(2)
           10
           >>> do_two_cycles = my_cycle(6)
           >>> do_two_cycles(1)
           19
           """
           "*** YOUR CODE HERE ***"
           def a(n):
               def b(x):
                   if not n:
                       return x
                   else:
                       i = 1
                       while i <= n:
                           if i % 3 == 1:
                               x = f1(x)
                           elif i % 3 == 2:
                               x = f2(x)
                           else:
                               x = f3(x)
                           i += 1
                       return x
               return b
           return a
           """solution"""
           def ret_fn(n):
               def ret(x):
                   i = 0
                   while i < n:
                       if i % 3 == 0:
                           x = f1(x)
                       elif i % 3 == 1:
                           x = f2(x)
                       else:
                           x = f3(x)
                       i += 1
                   return x
               return ret
           return ret_fn
     #+end_src 
     
     - Func name ~a~ -> ~ret_fn~ and ~b~ -> ~ret~
     - ~i = 0~ and ~while i < n~ to avoid discussing separately for ~n = 0~ 
* Lab 4 Python Lists, Data Abstraction
** Optional Questions
*** More Lists Practice
**** Q7: Flatten
     #+begin_src python :results output
       def flatten(lst):
           """Returns a flattened version of lst.

           >>> flatten([1, 2, 3])     # normal list
           [1, 2, 3]
           >>> x = [1, [2, 3], 4]      # deep list
           >>> flatten(x)
           [1, 2, 3, 4]
           >>> x = [[1, [1, 1]], 1, [1, 1]] # deep list
           >>> flatten(x)
           [1, 1, 1, 1, 1, 1]
           """
           "*** YOUR CODE HERE ***"
           # iterative and recursive
           flatten_lst = []
           for i in lst:
               if type(i) == list:
                   flatten_lst += flatten(i)
               else:
                   flatten_lst += [i]
           return flatten_lst
           """sol1"""
           # recursive
           if type(lst) != list:
               return [lst]
           else:
               return sum([flatten(elem) for elem in lst], [])
           """sol2"""
           # recursive
           if not lst:
               return []
           elif type(lst[0]) == list:
               return flatten(lst[0]) + flatten(lst[1:])
           else:
               return [lst[0]] + flatten(lst[1:])
     #+end_src 
     - About lists
       - ~type([]) = list~ = ~True~
       - ~bool([])~ = ~False~ and ~[][0]~ throws ~IndexError~ -> before calling ~lst[0]~, judge ~lst = []~ first to avoid ~IndexError~  
       - ~[a,b]+[c] = [a,b,c]~
       - ~sum([[1],[2],[3]],[]) = [1,2,3]~
     - Recursive
       - ~flatten(lst[0]) + flatten(lst[1:])~ and ~[lst[0]] + flatten(lst[1:])~
       - ~sum([flatten(elem) for elem in lst], [])~ 
***** Question:                                                   :QUESTIONS:
      1. 三种思路上有何不同，哪种更好（风格更好）？第二种明确给出了base，其他两种呢？

**** Q8: Merge
     #+begin_src python :results output
       def merge(lst1, lst2):
           """Merges two sorted lists.

           >>> merge([1, 3, 5], [2, 4, 6])
           [1, 2, 3, 4, 5, 6]
           >>> merge([], [2, 4, 6])
           [2, 4, 6]
           >>> merge([1, 2, 3], [])
           [1, 2, 3]
           >>> merge([5, 7], [2, 4, 6])
           [2, 4, 5, 6, 7]
           """
           "*** YOUR CODE HERE ***"
           # recursive
           if not lst1 or not lst2:
               return lst1 + lst2
           elif lst1[0] > lst2[0]:
               return [lst2[0]] + merge(lst1, lst2[1:])
           else:
               return [lst1[0]] + merge(lst2, lst1[1:])
           """sol1"""
           # iterative
           lst_sort = []
           while lst1 and lst2:
               if lst1[0] < lst2[0]:
                   lst_sort += [lst1[0]]
                   lst1 = lst1[1:]
               else:
                   lst_sort += [lst2[0]]
                   lst2 = lst2[1:]
           return lst_sort + lst1 if lst1 else lst_sort + lst2
     #+end_src 
     - Recursive: 
       - Judge ~not lst1 or not lst2~ before calling ~lst1[0]~ and ~lst2[0]~ to avoid ~IndexError~ 
       - ~[lst2[0]] + merge(lst1, lst2[1:])~ and ~[lst1[0]] + merge(lst2, lst1[1:])~ 
     - Iterative:
       - ~lst1 = lst1[1:]~ and ~lst2 = lst2[1:]~
       - ~lst_sort + lst1 if lst1 else lst_sort + lst2~ 
**** Q10: Updating the board
     #+begin_src python :results output
       def replace_elem(lst, index, elem):
           """Create and return a new list whose elements are the same as those in
           LST except at index INDEX, which should contain element ELEM instead.

           >>> old = [1, 2, 3, 4, 5, 6, 7]
           >>> new = replace_elem(old, 2, 8)
           >>> new
           [1, 2, 8, 4, 5, 6, 7]
           >>> new is old   # check that replace_elem outputs a new list
           False
           """
           assert index >= 0 and index < len(lst), 'Index is out of bounds'
           "*** YOUR CODE HERE ***"
           return lst[0:index] + [elem] + lst[index + 1:]
     #+end_src 
     - ~lst[0:index] + [elem] + lst[index + 1:]~ 
**** Q11: Manipulating pieces
     #+begin_src python :results output
       def get_piece(board, row, column):
           """Returns the piece at location (row, column) in the board.

           >>> rows, columns = 2, 2
           >>> board = create_board(rows, columns)
           >>> board = put_piece(board, rows, 0, 'X')[1] # Puts piece "X" in column 0 of board and updates board
           >>> board = put_piece(board, rows, 0, 'O')[1] # Puts piece "O" in column 0 of board and updates board
           >>> get_piece(board, 1, 0)
           'X'
           >>> get_piece(board, 1, 1)
           '-'
           """
           "*** YOUR CODE HERE ***"
           return board[row][column]


       def put_piece(board, max_rows, column, player):
           """Puts PLAYER's piece in the bottommost empty spot in the given column of
           the board. Returns a tuple of two elements:

               1. The index of the row the piece ends up in, or -1 if the column
                  is full.
               2. The new board

           >>> rows, columns = 2, 2
           >>> board = create_board(rows, columns)
           >>> row, new_board = put_piece(board, rows, 0, 'X')
           >>> row
           1
           >>> row, new_board = put_piece(new_board, rows, 0, 'O')
           >>> row
           0
           >>> row, new_board = put_piece(new_board, rows, 0, 'X')
           >>> row
           -1
           """
           "*** YOUR CODE HERE ***"
           if not board[0][column] == '-':
               return -1, board
           else:
               while max_rows > 0:
                   if board[max_rows - 1][column] == '-':
                       new_board = replace_elem(board[max_rows - 1], column, player)
                       new_board = replace_elem(board, max_rows - 1, new_board)
                       return max_rows - 1, new_board
                   max_rows -= 1
     #+end_src 
     - ~put_piece~ is a *one shot func, not recursive*
     - ~new_board = replace_elem(board[max_rows - 1], column, player)~ and ~new_board = replace_elem(board, max_rows - 1, new_board)~  

**** Q12: Making a move
     #+begin_src python :results output
       def make_move(board, max_rows, max_cols, col, player):
           """Put player's piece in column COL of the board, if it is a valid move.
           Return a tuple of two values:

               1. If the move is valid, make_move returns the index of the row the
                  piece is placed in. Otherwise, it returns -1.
               2. The updated board

           >>> rows, columns = 2, 2
           >>> board = create_board(rows, columns)
           >>> row, board = make_move(board, rows, columns, 0, 'X')
           >>> row
           1
           >>> get_piece(board, 1, 0)
           'X'
           >>> row, board = make_move(board, rows, columns, 0, 'O')
           >>> row
           0
           >>> row, board = make_move(board, rows, columns, 0, 'X')
           >>> row
           -1
           >>> row, board = make_move(board, rows, columns, -4, '0')
           >>> row
           -1
           """
           "*** YOUR CODE HERE ***"
           if col >= 0 and col < max_cols:
               return put_piece(board, max_rows, col, player)
           else:
               return -1, board
     #+end_src 
     - Set ~col~ range: ~col >= 0 and col < max_cols~ 
     - Use ~put_piece~ to *avoid violating abstraction barrier* 
**** Q13: Printing and viewing the board
     #+begin_src python :results output
       def print_board(board, max_rows, max_cols):
           """Prints the board. Row 0 is at the top, and column 0 at the far left.

           >>> rows, columns = 2, 2
           >>> board = create_board(rows, columns)
           >>> print_board(board, rows, columns)
           - -
           - -
           >>> new_board = make_move(board, rows, columns, 0, 'X')[1]
           >>> print_board(new_board, rows, columns)
           - -
           X -
           """
           "*** YOUR CODE HERE ***"
           row, connection = 0, ' '
           while row < max_rows:
               print (connection.join(board[row]))
               row += 1
     #+end_src 
     - ~print(object)~ automatically line break
     - ~str.join(sequence)~  
**** Q14: Checking for victory
     #+begin_src python :results output
       def check_win_row(board, max_rows, max_cols, num_connect, row, player):
           """ Returns True if the given player has a horizontal win
           in the given row, and otherwise False.

           >>> rows, columns, num_connect = 4, 4, 2
           >>> board = create_board(rows, columns)
           >>> board = make_move(board, rows, columns, 0, 'X')[1]
           >>> board = make_move(board, rows, columns, 0, 'O')[1]
           >>> check_win_row(board, rows, columns, num_connect, 3, 'O')
           False
           >>> board = make_move(board, rows, columns, 2, 'X')[1]
           >>> board = make_move(board, rows, columns, 0, 'O')[1]
           >>> check_win_row(board, rows, columns, num_connect, 3, 'X')
           False
           >>> board = make_move(board, rows, columns, 1, 'X')[1]
           >>> check_win_row(board, rows, columns, num_connect, 3, 'X')
           True
           >>> check_win_row(board, rows, columns, 4, 3, 'X')    # A win depends on the value of num_connect
           False
           >>> check_win_row(board, rows, columns, num_connect, 3, 'O')   # We only detect wins for the given player
           False
           """
           "*** YOUR CODE HERE ***"
           if row >= 0 and row < max_rows:
               # return sum([1 for i in board[row] if i == player]) >= num_connect
               return num_connect * player in ''.join(board[row])
           else:
               return False

       def check_win_column(board, max_rows, max_cols, num_connect, col, player):
           """ Returns True if the given player has a vertical win in the given column,
           and otherwise False.

           >>> rows, columns, num_connect = 5, 5, 2
           >>> board = create_board(rows, columns)
           >>> board = make_move(board, rows, columns, 0, 'X')[1]
           >>> board = make_move(board, rows, columns, 1, 'O')[1]
           >>> check_win_column(board, rows, columns, num_connect, 0, 'X')
           False
           >>> board = make_move(board, rows, columns, 1, 'X')[1]
           >>> board = make_move(board, rows, columns, 1, 'O')[1]
           >>> check_win_column(board, rows, columns, num_connect, 1, 'O')
           False
           >>> board = make_move(board, rows, columns, 2, 'X')[1]
           >>> board = make_move(board, rows, columns, 1, 'O')[1]
           >>> check_win_column(board, rows, columns, num_connect, 1, 'O')
           True
           >>> check_win_column(board, rows, columns, 4, 1, 'O')
           False
           >>> check_win_column(board, rows, columns, num_connect, 1, 'X')
           False
           """
           "*** YOUR CODE HERE ***"
           if col >= 0 and col < max_cols:
               return num_connect * player in ''.join(list(zip(*board))[col])
           else:
               return False
     #+end_src 
     - ~[a] * 3~ = ~[a, a, a]~, ~'a' * 3~ = ~'aaa'~, ~'aaa' in 'aaabaa'~ = ~True~   
     - ~''.join(['a','b'])~ = ~''.join(('a','b'))~ = ~'ab'~
     - ~list(zip(*[[1,2],[3,4]]))~ = ~[(1,3), (2,4)]~,    
     - ~num_connect * player in ''.join(board[row])~ and ~num_connect * player in ''.join(list(zip(*board))[col])~ 
**** Question                                                     :QUESTIONS:
     1. 关于Connect N整个程序的函数和数据抽象思想进一步思考
        
* Lab 5 Python Lists, Trees 
** Required Questions
   #+begin_src python :results output
     # Tree ADT
     def tree(label, branches=[]):
         """Construct a tree with the given label value and a list of branches."""
         for branch in branches:
             assert is_tree(branch), 'branches must be trees'
         return [label] + list(branches)

     def label(tree):
         """Return the label value of a tree."""
         return tree[0]

     def branches(tree):
         """Return the list of branches of the given tree."""
         return tree[1:]

     def is_tree(tree):
         """Returns True if the given tree is a tree, and False otherwise."""
         if type(tree) != list or len(tree) < 1:
             return False
         for branch in branches(tree):
             if not is_tree(branch):
                 return False
         return True

     def is_leaf(tree):
         """Returns True if the given tree's list of branches is empty, and False
         otherwise.
         """
         return not branches(tree)

     def print_tree(t, indent=0):
         """Print a representation of this tree in which each node is
         indented by two spaces times its depth from the root.

         >>> print_tree(tree(1))
         1
         >>> print_tree(tree(1, [tree(2)]))
         1
           2
         >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])
         >>> print_tree(numbers)
         1
           2
           3
             4
             5
           6
             7
         """
         print('  ' * indent + str(label(t)))
         for b in branches(t):
             print_tree(b, indent + 1)

     def copy_tree(t):
         """Returns a copy of t. Only for testing purposes.

         >>> t = tree(5)
         >>> copy = copy_tree(t)
         >>> t = tree(6)
         >>> print_tree(copy)
         5
         """
         return tree(label(t), [copy_tree(b) for b in branches(t)])
   #+end_src 
*** Q1: Acorn Finder
    #+begin_src python :results output
      def acorn_finder(t):
          """Returns True if t contains a node with the value 'acorn' and
          False otherwise.

          >>> scrat = tree('acorn')
          >>> acorn_finder(scrat)
          True
          >>> sproul = tree('roots', [tree('branch1', [tree('leaf'), tree('acorn')]), tree('branch2')])
          >>> acorn_finder(sproul)
          True
          >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])
          >>> acorn_finder(numbers)
          False
          """
          "*** YOUR CODE HERE ***"
          result = False
          if is_leaf(t):
              return label(t) == 'acorn'
          if label(t) == 'acorn':
              return True
          else:
              for branch in branches(t):
                  result = result or acorn_finder(branch)
                  if result:
                      return True
              return result
    #+end_src 
    - ~result = False~ and ~result = result or acorn_finder(branch)~
    - Recursion in iteration
*** Q2: Pruning Leaves
    #+begin_src python :results output
      def prune_leaves(t, vals):
          """Return a modified copy of t with all leaves that have a label
          that appears in vals removed.  Return None if the entire tree is
          pruned away.

          >>> t = tree(2)
          >>> print(prune_leaves(t, (1, 2)))
          None
          >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])
          >>> print_tree(numbers)
          1
            2
            3
              4
              5
            6
              7
          >>> print_tree(prune_leaves(numbers, (3, 4, 6, 7)))
          1
            2
            3
              5
            6
          """
          "*** YOUR CODE HERE ***"
          prune_t = [label(t)]
          if is_leaf(t):
              return None if label(t) in vals else t
          else:
              for i in branches(t):
                  if prune_leaves(i, vals):
                      prune_t.append(prune_leaves(i, vals))
                      # or prune_t += [prune_leaves(i, vals)]
              return prune_t
    #+end_src 
    - ~prune_t = [label(t)]~ 
    - ~prune_t.append(prune_leaves(i, vals))~ if ~prune_leaves(i, vals)~ is not ~None~
    - ~list += [...] = ~list.append(...)~ = ~list.extend([...])~ (while ~append~ and ~extend~ are mutable operations, ~+~ creates a new list)
*** Q3: Memory
    #+begin_src python :results output
      def memory(n):
          """
          >>> f = memory(10)
          >>> f(lambda x: x * 2)
          20
          >>> f(lambda x: x - 7)
          13
          >>> f(lambda x: x > 5)
          True
          """
          "*** YOUR CODE HERE ***"
          def f(g):
              nonlocal n
              n = g(n)
              return n
          return f
    #+end_src 
    - ~nonlocal n~ and ~n = g(n)~ 
*** Question:                                                     :QUESTIONS:
    1. 关于 recursion in iteration，这么写规范吗？能否用纯 iteration 或 recursion 改写？能不能有什么本质原因？（什么样的问题必须用 recursion in iteration才能比较好的解决？）
    2. 有没有 iteration in recursion？同1疑问
** Optional Questions
*** Shakespeare and Dictionaries
**** Q4: Successor Tables
     #+begin_src python :results output
       def build_successors_table(tokens):
           """Return a dictionary: keys are words; values are lists of successors.

           >>> text = ['We', 'came', 'to', 'investigate', ',', 'catch', 'bad', 'guys', 'and', 'to', 'eat', 'pie', '.']
           >>> table = build_successors_table(text)
           >>> sorted(table)
           [',', '.', 'We', 'and', 'bad', 'came', 'catch', 'eat', 'guys', 'investigate', 'pie', 'to']
           >>> table['to']
           ['investigate', 'eat']
           >>> table['pie']
           ['.']
           >>> table['.']
           ['We']
           """
           table = {}
           prev = '.'
           for word in tokens:
               if prev not in table:
                   "*** YOUR CODE HERE ***"
                   table[prev] = [word]
               else:
                   table[prev].append(word)
               "*** YOUR CODE HERE ***"
               prev = word
           return table
     #+end_src 
     - ~prev = '.'~ with ~for word in tokens~ or ~prev = tokens[0]~ with ~for word in tokens.append(tokens[0])~, then ~prev = word~ in the *final* of each iteration to get *two adjacent elements* in ~tokens~ as ~[prev, word]~
     - ~table[prev] = [word]~ and ~table[prev].append(word)~ 
**** Q5: Construct the Sentence
     #+begin_src python :results output
       def construct_sent(word, table):
           """Prints a random sentence starting with word, sampling from
           table.

           >>> table = {'Wow': ['!'], 'Sentences': ['are'], 'are': ['cool'], 'cool': ['.']}
           >>> construct_sent('Wow', table)
           'Wow!'
           >>> construct_sent('Sentences', table)
           'Sentences are cool.'
           """
           import random
           result = ''
           while word not in ['.', '!', '?']:
               "*** YOUR CODE HERE ***"
               result = result + word + ' '
               word = random.choice(table[word])
           return result.strip() + word
     #+end_src 
     - ~while word not in ['.', '!', '?']~
     - ~result = result + word + ' '~ and ~word = random.choice(table[word])~
     - ~' a b c '.strip()~ = ~'a b c'~ 
     Putting it all together
     #+begin_src python :results output
       def shakespeare_tokens(path='shakespeare.txt', url='http://composingprograms.com/shakespeare.txt'):
           """Return the words of Shakespeare's plays as a list."""
           import os
           from urllib.request import urlopen
           if os.path.exists(path):
               return open('shakespeare.txt', encoding='ascii').read().split()
           else:
               shakespeare = urlopen(url)
               return shakespeare.read().decode(encoding='ascii').split()

       # Uncomment the following two lines
       tokens = shakespeare_tokens()
       table = build_successors_table(tokens)

       def random_sent():
           import random
           return construct_sent(random.choice(table['.']), table)
     #+end_src 
**** Question:                                                   :QUESTIONS:
     1. Q4中如果要取满足某种条件的3个相邻元素呢？有何一般方法？
*** More Trees Practice
**** Q6: Sprout leaves
     #+begin_src python :results output
       def sprout_leaves(t, vals):
           """Sprout new leaves containing the data in vals at each leaf in
           the original tree t and return the resulting tree.

           >>> t1 = tree(1, [tree(2), tree(3)])
           >>> print_tree(t1)
           1
             2
             3
           >>> new1 = sprout_leaves(t1, [4, 5])
           >>> print_tree(new1)
           1
             2
               4
               5
             3
               4
               5

           >>> t2 = tree(1, [tree(2, [tree(3)])])
           >>> print_tree(t2)
           1
             2
               3
           >>> new2 = sprout_leaves(t2, [6, 1, 2])
           >>> print_tree(new2)
           1
             2
               3
                 6
                 1
                 2
           """
           "*** YOUR CODE HERE ***"
           if is_leaf(t):
               for i in vals:
                   t.append([i])
               return t
           sprout_t = [label(t)]
           for branch in branches(t):
               sprout_t.append(sprout_leaves(branch, vals))
           return sprout_t
     #+end_src 
     - ~sprout_t = [label(t)]~ and ~sprout_t.append(sprout_leaves(branch, vals))~ 
**** Q7: Add trees
     #+begin_src python :results output
       def add_trees(t1, t2):
           """
           >>> numbers = tree(1,
           ...                [tree(2,
           ...                      [tree(3),
           ...                       tree(4)]),
           ...                 tree(5,
           ...                      [tree(6,
           ...                            [tree(7)]),
           ...                       tree(8)])])
           >>> print_tree(add_trees(numbers, numbers))
           2
             4
               6
               8
             10
               12
                 14
               16
           >>> print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))
           5
             4
             5
           >>> print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))
           4
             6
             4
           >>> print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \
           tree(2, [tree(3, [tree(4)]), tree(5)])))
           4
             6
               8
               5
             5
           """
           "*** YOUR CODE HERE ***" 
           if len(t1) > len(t2):
               t2 += (len(t1) - len(t2)) * [[0]]
           else:
               t1 += (len(t2) - len(t1)) * [[0]]
           add_t = [label(t1) + label(t2)]
           if is_leaf(t1):
               return add_t
           else:
               for branch1, branch2 in zip(branches(t1), branches(t2)):
                   add_t.append(add_trees(list(branch1), list(branch2)))
               return add_t
     #+end_src 
     - ~t2 += (len(t1) - len(t2)) * [[0]]~ and ~t1 += (len(t2) - len(t1)) * [[0]]~ -> ~add_t = [label(t1) + label(t2)]~
     - ~x, y = zip([1, 2], [3, 4])~ -> 2 *tuples* ~x = (1, 3)~ and ~y = (2, 4)~
     - ~for branch1, branch2 in zip(branches(t1), branches(t2)):~ and ~add_t.append(add_trees(list(branch1), list(branch2)))~
     - In tree "recursive in iterative" func, base condition is usually ~is_leaf(t)~, recursive func usually invokes on ~branches(t)~, and final return value usually combines ~label(t)~ and *recursive result*.
**** Question:                                                    :QUESTIONS:
     1. Q7有没有更优的办法？比如不需要消耗内存补0的方法
        
