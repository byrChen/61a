#+TAGS: OUTSTANDING(o) QUESTIONS(q) TOBEORG(t)

* Lab 0 Workflow and Python Basics
  - Unlock tests: ~python ok -q testname -u~
  - Run tests: ~python ok~
  - Show all tests: ~python ok -v~ 
  - Run .py in an interactive session: ~python -i .py~
  - Run doctests in .py: ~python -m doctest .py~ 
* Lab 1 Function and Control
** Topics
*** Functions
**** ~return~ and ~print~  
     - ~return~: When Python executes a *return statement*, the function *terminates immediately*. If Python reaches the end of the function body *without executing a return statement*, it will *automatically return None*.
     - ~print~: When Python evaluates a *print expression*, the function does *not terminate immediately*.
     
     #+begin_src python :results output
       def what_prints():
           print('Hello World!')
           return 'Exiting this function.'
           print('61A is awesome!')

       print(what_prints())
     #+end_src 

     #+RESULTS:
     : Hello World!
     : Exiting this function.
 
*** Control
**** Boolean Operators

     | booblean operators | priority |
     | ~not~              | highest  |
     | ~and~              | medium   |
     | ~or~               | lowest   |

     For *A is True* and *B is False*

     | expression       | return  |
     | ~A and C~        | ~C~     |
     | ~A or C~         | ~A~     |
     | ~B and C~        | ~B~     |
     | ~B or C~         | ~C~     |
     | ~Error and/or C~ | ~Error~ |
     
     ~and~ and ~or~ *don't always return booleans* when using values other than ~True and False~: A,B,C above, they can be booleans, numbers, strings and even ~Error~.
     
*** Error Messages

    | Error Types         | Descriptions                              |
    | ~SyntaxError~       | Contained improper syntax                 |
    | ~IndentationError~  | Contained improper indentation            |
    | ~TypeError~         | Attempted operation on incompatible types |
    | ~ZeroDivisionError~ | Attempted division by zero                |

** Required Questions
*** Coding Practice
**** Q4: Sum Digits

     #+begin_src python :results output
       def sum_digits(n):
           """Sum all the digits of n.

           >>> sum_digits(10) # 1 + 0 = 1
           1
           >>> sum_digits(4224) # 4 + 2 + 2 + 4 = 12
           12
           >>> sum_digits(1234567890)
           45
           """
           "*** YOUR CODE HERE ***"
           s = 0
           while n // 10 > 0:
               r = n % 10
               n = (n - r) // 10
               s += r
           return s + n % 10
           "***SOLUTION***"
           total = 0
           while n > 0:
               total, n = total + n % 10, n // 10
           return total
     #+end_src 

** Optional Questions
*** Q6: Falling Factorial

    #+begin_src python :results output
      def falling(n, k):
          """Compute the falling factorial of n to depth k.

          >>> falling(6, 3)  # 6 * 5 * 4
          120
          >>> falling(4, 0)
          1
          >>> falling(4, 3)  # 4 * 3 * 2
          24
          >>> falling(4, 1)  # 4
          4
          """
          "*** YOUR CODE HERE ***"
          a = n
          f = 1
          while k > 0:
              f = f * a
              k -= 1
              a -= 1
          return f
          "***SOLUTION***"
          total, stop = 1, n-k
          while n > stop:
              total, n = total*n, n-1
          return total
    #+end_src 

*** Q7: Double Eights

    #+begin_src python :results output
      def double_eights(n):
          """Return true if n has two eights in a row.
          >>> double_eights(8)
          False
          >>> double_eights(88)
          True
          >>> double_eights(2882)
          True
          >>> double_eights(880088)
          True
          >>> double_eights(12345)
          False
          >>> double_eights(80808080)
          False
          """
          "*** YOUR CODE HERE ***"
          while n // 10 > 0:
              if n % 100 == 88:
                  break
              else:
                  n = (n - n % 10) // 10
          if n // 10 == 0:
              return False
          else:
              return True
          "***SOLUTION***"
          prev_eight = False
          while n > 0:
              last_digit = n % 10
              if last_digit == 8 and prev_eight:
                  return True
              elif last_digit == 8:
                  prev_eight = True
              else:
                  prev_eight = False
              n = n // 10
          return False
    #+end_src 

* Lab 2 Higher Order Functions
** Topics
*** Lambda Expressions
    ~lambda <parameters>: <return expression>~. 
**** ~lambda~ vs ~def~   

     |                     | ~lambda~                                                                                       | ~def~                                                                                                          |
     | Type                | /Expression/ that evaluates to a value                                                         | /Statement/ that *alters the env*                                                                              |
     | Result of execution | Creates an *anonymous lambda function* with *no intrinsic* name                                | Creates a *function* with an *intrinsic* name and binds it to that name in the *current env*                   |
     | Effect on the env   | *Evaluating* a ~lambda~ *expression* does *not* create or modify any variables(change the env) | Executing a ~def~ *statement* both creates a *new function* object and binds it to a name in the *current env* |
     
***** Example

      #+begin_src python :results output
        lambda x: x * x #no binding created
        square = lambda x: x * x
        square(4) #calling a lambda function
      #+end_src 

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 21:05:16
      [[file:pictures/Lab%202%20Higher%20Order%20Functions/screenshot_2019-03-31_21-05-16.png]]

***** Two ways of def funcs 

      #+begin_src python :results output
          a = lambda <paras(1)>: lambda <paras(2)>: ... : lambda <paras(n)>: <expression>

          def a(paras(1)):
              def a2(paras(2)):
                  ...
                  def an(paras(n)):
                      return <expression>
                  return a3
              return a2
      #+end_src 
      
      However, in ~lambda~ method func ~a~ points to a *non-intrinsic name* func object, while in ~def~ method func ~a~ points to a func whose *intrinsic name* is ~a~.

** Required Questions 
*** What Would Python Display?
**** Q1: WWPD: Lambda the Free
   
     #+begin_example
       >>> (lambda: 3)()  # Using a lambda expression as an operator in a call exp.
       3
       >>> b = lambda x: lambda: x  # Lambdas can return other lambdas!
       >>> c = b(88)
       >>> c
       Function
       >>> c()
       88

       >>> z = 3
       >>> e = lambda x: lambda y: lambda: x + y + z
       >>> e(0)(1)()
       4
       >>> f = lambda z: x + z
       >>> f(3)
       Error

       >>> higher_order_lambda = lambda f: lambda x: f(x)
       >>> g = lambda x: x * x
       >>> higher_order_lambda(2)(g) # Which argument belongs to which function call?
       Error
       >>> higher_order_lambda(g)(2)
       4
       >>> call_thrice = lambda f: lambda x: f(f(f(x)))
       >>> call_thrice(lambda y: y + 1)(0)
       3
       >>> print_lambda = lambda z: print(z)
       >>> print_lambda
       Function
       >>> one_thousand = print_lambda(1000)
       1000
       >>> one_thousand
       Nothing
     #+end_example

**** Q2: WWPD: Higher Order Functions

     #+begin_example
       >>> def even(f):
       ...     def odd(x):
       ...         if x < 0:
       ...             return f(-x)
       ...         return f(x)
       ...     return odd
       >>> steven = lambda x: x
       >>> stewart = even(steven)
       >>> stewart
       Function
       >>> stewart(61)
       61
       >>> stewart(-4)
       4

       >>> higher_order_lambda = lambda f: lambda x: f(x)
       >>> def cake():
       ...    print('beets')
       ...    def pie():
       ...        print('sweets')
       ...        return 'cake'
       ...    return pie
       >>> chocolate = cake()
       beets
       >>> chocolate
       Function
       >>> chocolate()
       sweets
       'cake'
       >>> more_chocolate, more_cake = chocolate(), cake
       sweets
       >>> more_chocolate
       'cake'
       >>> def snake(x, y):
       ...    if cake == more_cake:
       ...        return lambda: x + y
       ...    else:
       ...        return x + y
       >>> snake(10, 20)
       Function
       >>> snake(10, 20)()
       30
       >>> cake = 'cake'
       >>> snake(10, 20)
       30
     #+end_example

*** Coding Practice
**** Q3: Lambdas and Currying

     #+begin_src python :results output
       def lambda_curry2(func):
           """
           Returns a Curried version of a two-argument function FUNC.
           >>> from operator import add
           >>> curried_add = lambda_curry2(add)
           >>> add_three = curried_add(3)
           >>> add_three(5)
           8
           """
           "*** YOUR CODE HERE ***"
           return lambda x: lambda y: func(x, y)
     #+end_src 
     
** Optional Questions
*** Environment Diagram Practice
**** Q4: Make Adder

     #+begin_src python :results output
       n = 9
       def make_adder(n):
           return lambda k: k + n
       add_ten = make_adder(n+1)
       result = add_ten(n)
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 22:41:46
     [[file:pictures/Lab%202%20Higher%20Order%20Functions/screenshot_2019-03-31_22-41-46.png]]
     
     1. ~add_ten~ is evaluated in *Global* while ~lambda k: k + n~ was evaluated in *f1*.
     2. In *Global* ~n=9~ while in *f1* ~n=10~, ~add_ten(n)~ firstly passes(*finds*) ~n=9~ to ~k~ under *Global*, secondly passes(*finds*) ~n=10~ to ~n~ under *f1*, finally returns ~9 + 10~.
     3. ~add_ten(n)~ = ~make_adder(n+1)(n)~.
 
**** Q5: Lambda the Environment Diagram

     #+begin_src python :results output
       a = lambda x: x * 2 + 1
       def b(b, x):
           return b(x + a(x))

       x = 3
       b(a, x)
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 22:47:46
     [[file:pictures/Lab%202%20Higher%20Order%20Functions/screenshot_2019-03-31_22-47-46.png]]

     1. A *new frame created* when *calling of a func* finished *passing* (and perhaps *calculating*) *func name* and *args* under *present(or previous) frame* to its *func signature(name and paras)*, then the *body of func* will be executed under this *new frame*. 
     2. Created frame's *parent* frame = the frame where the *called func is evaluated*, not the frame where the *called func is called*.
     3. ~b(a, x)~ firstly passes *func ~b~, args ~a = lambda x: x * 2 + 1~ and ~x=3~ under Global* to *func signature(no need to calculate)*, then *f1* created, *f1's parent=Global* as ~b~ is evaluated under *Global*.
     4. Calling of ~b(x + a(x))~ under *f1* passes *func ~b=a~, args ~x=3~ under f1* and *args ~a = lambda x: x * 2 + 1~ under Global(previous)* to *func signature(need to calculate args ~x + a(x)~)*. ~a(x)~ which *called under f1* passes *args ~x=3~ under f1, func ~a = lambda x: x * 2 + 1~ under Global(previous)* to *func signature(no need to calculate)* and then creat *f2*, *f2's parent is Global, not f1*, as ~a~ is evaluated under *Global(~a~'s parent is Global)*.          
     5. ~b(x + a(x))~ passes *func ~b=a~, args ~x + a(x) = 10~ under f1* and *func ~a = lambda x: x * 2 + 1~ under Global* to *func signature(no need to calculate)*, then *f3* created, *f3's parent=Global* as ~a~ is evaluated under *Global*.
 
*** More Coding Practice
**** Q6: Composite Identity Function                            

**** Q7: Count van Count

     #+begin_src python :results output
       def count_cond(condition):
           """Returns a function with one parameter N that counts all the numbers from
           1 to N that satisfy the two-argument predicate function Condition, where
           the first argument for Condition is N and the second argument is the
           number from 1 to N.

           >>> count_factors = count_cond(lambda n, i: n % i == 0)
           >>> count_factors(2)   # 1, 2
           2
           >>> count_factors(4)   # 1, 2, 4
           3
           >>> count_factors(12)  # 1, 2, 3, 4, 6, 12
           6

           >>> is_prime = lambda n, i: count_factors(i) == 2
           >>> count_primes = count_cond(is_prime)
           >>> count_primes(2)    # 2
           1
           >>> count_primes(3)    # 2, 3
           2
           >>> count_primes(4)    # 2, 3
           2
           >>> count_primes(5)    # 2, 3, 5
           3
           >>> count_primes(20)   # 2, 3, 5, 7, 11, 13, 17, 19
           8
           """
           "*** YOUR CODE HERE ***"
           def a(N):
               i, count = 1, 0
               while i <= N:
                   if condition(N, i):
                       count += 1
                   i += 1
               return  count
           return a
     #+end_src 

     - Func name ~a~ can be ~counter~ 

**** Q8: I Heard You Liked Functions...

     #+begin_src python :results output
       def cycle(f1, f2, f3):
           """Returns a function that is itself a higher-order function.

           >>> def add1(x):
           ...     return x + 1
           >>> def times2(x):
           ...     return x * 2
           >>> def add3(x):
           ...     return x + 3
           >>> my_cycle = cycle(add1, times2, add3)
           >>> identity = my_cycle(0)
           >>> identity(5)
           5
           >>> add_one_then_double = my_cycle(2)
           >>> add_one_then_double(1)
           4
           >>> do_all_functions = my_cycle(3)
           >>> do_all_functions(2)
           9
           >>> do_more_than_a_cycle = my_cycle(4)
           >>> do_more_than_a_cycle(2)
           10
           >>> do_two_cycles = my_cycle(6)
           >>> do_two_cycles(1)
           19
           """
           "*** YOUR CODE HERE ***"
           def a(n):
               def b(x):
                   if not n:
                       return x
                   else:
                       i = 1
                       while i <= n:
                           if i % 3 == 1:
                               x = f1(x)
                           elif i % 3 == 2:
                               x = f2(x)
                           else:
                               x = f3(x)
                           i += 1
                       return x
               return b
           return a
           """solution"""
           def ret_fn(n):
               def ret(x):
                   i = 0
                   while i < n:
                       if i % 3 == 0:
                           x = f1(x)
                       elif i % 3 == 1:
                           x = f2(x)
                       else:
                           x = f3(x)
                       i += 1
                   return x
               return ret
           return ret_fn
     #+end_src 
     
     - Func name ~a~ -> ~ret_fn~ and ~b~ -> ~ret~
     - ~i = 0~ and ~while i < n~ to avoid discussing separately for ~n = 0~ 
* Lab 4 Python Lists, Data Abstraction
** Optional Questions
*** More Lists Practice
**** Q7: Flatten
     #+begin_src python :results output
       def flatten(lst):
           """Returns a flattened version of lst.

           >>> flatten([1, 2, 3])     # normal list
           [1, 2, 3]
           >>> x = [1, [2, 3], 4]      # deep list
           >>> flatten(x)
           [1, 2, 3, 4]
           >>> x = [[1, [1, 1]], 1, [1, 1]] # deep list
           >>> flatten(x)
           [1, 1, 1, 1, 1, 1]
           """
           "*** YOUR CODE HERE ***"
           # iterative and recursive
           flatten_lst = []
           for i in lst:
               if type(i) == list:
                   flatten_lst += flatten(i)
               else:
                   flatten_lst += [i]
           return flatten_lst
           """sol1"""
           # recursive
           if type(lst) != list:
               return [lst]
           else:
               return sum([flatten(elem) for elem in lst], [])
           """sol2"""
           # recursive
           if not lst:
               return []
           elif type(lst[0]) == list:
               return flatten(lst[0]) + flatten(lst[1:])
           else:
               return [lst[0]] + flatten(lst[1:])
     #+end_src 
     - About lists
       - ~type([]) = list~ = ~True~
       - ~bool([])~ = ~False~ and ~[][0]~ throws ~IndexError~ -> before calling ~lst[0]~, judge ~lst = []~ first to avoid ~IndexError~  
       - ~[a,b]+[c] = [a,b,c]~
       - ~sum([[1],[2],[3]],[]) = [1,2,3]~
     - Recursive
       - ~flatten(lst[0]) + flatten(lst[1:])~ and ~[lst[0]] + flatten(lst[1:])~
       - ~sum([flatten(elem) for elem in lst], [])~ 
***** Question:                                                   :QUESTIONS:
      1. 三种思路上有何不同，哪种更好（风格更好）？第二种明确给出了base，其他两种呢？

**** Q8: Merge
     #+begin_src python :results output
       def merge(lst1, lst2):
           """Merges two sorted lists.

           >>> merge([1, 3, 5], [2, 4, 6])
           [1, 2, 3, 4, 5, 6]
           >>> merge([], [2, 4, 6])
           [2, 4, 6]
           >>> merge([1, 2, 3], [])
           [1, 2, 3]
           >>> merge([5, 7], [2, 4, 6])
           [2, 4, 5, 6, 7]
           """
           "*** YOUR CODE HERE ***"
           # recursive
           if not lst1 or not lst2:
               return lst1 + lst2
           elif lst1[0] > lst2[0]:
               return [lst2[0]] + merge(lst1, lst2[1:])
           else:
               return [lst1[0]] + merge(lst2, lst1[1:])
           """sol1"""
           # iterative
           lst_sort = []
           while lst1 and lst2:
               if lst1[0] < lst2[0]:
                   lst_sort += [lst1[0]]
                   lst1 = lst1[1:]
               else:
                   lst_sort += [lst2[0]]
                   lst2 = lst2[1:]
           return lst_sort + lst1 if lst1 else lst_sort + lst2
     #+end_src 
     - Recursive: 
       - Judge ~not lst1 or not lst2~ before calling ~lst1[0]~ and ~lst2[0]~ to avoid ~IndexError~ 
       - ~[lst2[0]] + merge(lst1, lst2[1:])~ and ~[lst1[0]] + merge(lst2, lst1[1:])~ 
     - Iterative:
       - ~lst1 = lst1[1:]~ and ~lst2 = lst2[1:]~
       - ~lst_sort + lst1 if lst1 else lst_sort + lst2~ 
**** Q10: Updating the board
     #+begin_src python :results output
       def replace_elem(lst, index, elem):
           """Create and return a new list whose elements are the same as those in
           LST except at index INDEX, which should contain element ELEM instead.

           >>> old = [1, 2, 3, 4, 5, 6, 7]
           >>> new = replace_elem(old, 2, 8)
           >>> new
           [1, 2, 8, 4, 5, 6, 7]
           >>> new is old   # check that replace_elem outputs a new list
           False
           """
           assert index >= 0 and index < len(lst), 'Index is out of bounds'
           "*** YOUR CODE HERE ***"
           return lst[0:index] + [elem] + lst[index + 1:]
     #+end_src 
     - ~lst[0:index] + [elem] + lst[index + 1:]~ 
**** Q11: Manipulating pieces
     #+begin_src python :results output
       def get_piece(board, row, column):
           """Returns the piece at location (row, column) in the board.

           >>> rows, columns = 2, 2
           >>> board = create_board(rows, columns)
           >>> board = put_piece(board, rows, 0, 'X')[1] # Puts piece "X" in column 0 of board and updates board
           >>> board = put_piece(board, rows, 0, 'O')[1] # Puts piece "O" in column 0 of board and updates board
           >>> get_piece(board, 1, 0)
           'X'
           >>> get_piece(board, 1, 1)
           '-'
           """
           "*** YOUR CODE HERE ***"
           return board[row][column]


       def put_piece(board, max_rows, column, player):
           """Puts PLAYER's piece in the bottommost empty spot in the given column of
           the board. Returns a tuple of two elements:

               1. The index of the row the piece ends up in, or -1 if the column
                  is full.
               2. The new board

           >>> rows, columns = 2, 2
           >>> board = create_board(rows, columns)
           >>> row, new_board = put_piece(board, rows, 0, 'X')
           >>> row
           1
           >>> row, new_board = put_piece(new_board, rows, 0, 'O')
           >>> row
           0
           >>> row, new_board = put_piece(new_board, rows, 0, 'X')
           >>> row
           -1
           """
           "*** YOUR CODE HERE ***"
           if not board[0][column] == '-':
               return -1, board
           else:
               while max_rows > 0:
                   if board[max_rows - 1][column] == '-':
                       new_board = replace_elem(board[max_rows - 1], column, player)
                       new_board = replace_elem(board, max_rows - 1, new_board)
                       return max_rows - 1, new_board
                   max_rows -= 1
     #+end_src 
     - ~put_piece~ is a *one shot func, not recursive*
     - ~new_board = replace_elem(board[max_rows - 1], column, player)~ and ~new_board = replace_elem(board, max_rows - 1, new_board)~  

**** Q12: Making a move
     #+begin_src python :results output
       def make_move(board, max_rows, max_cols, col, player):
           """Put player's piece in column COL of the board, if it is a valid move.
           Return a tuple of two values:

               1. If the move is valid, make_move returns the index of the row the
                  piece is placed in. Otherwise, it returns -1.
               2. The updated board

           >>> rows, columns = 2, 2
           >>> board = create_board(rows, columns)
           >>> row, board = make_move(board, rows, columns, 0, 'X')
           >>> row
           1
           >>> get_piece(board, 1, 0)
           'X'
           >>> row, board = make_move(board, rows, columns, 0, 'O')
           >>> row
           0
           >>> row, board = make_move(board, rows, columns, 0, 'X')
           >>> row
           -1
           >>> row, board = make_move(board, rows, columns, -4, '0')
           >>> row
           -1
           """
           "*** YOUR CODE HERE ***"
           if col >= 0 and col < max_cols:
               return put_piece(board, max_rows, col, player)
           else:
               return -1, board
     #+end_src 
     - Set ~col~ range: ~col >= 0 and col < max_cols~ 
     - Use ~put_piece~ to *avoid violating abstraction barrier* 
**** Q13: Printing and viewing the board
     #+begin_src python :results output
       def print_board(board, max_rows, max_cols):
           """Prints the board. Row 0 is at the top, and column 0 at the far left.

           >>> rows, columns = 2, 2
           >>> board = create_board(rows, columns)
           >>> print_board(board, rows, columns)
           - -
           - -
           >>> new_board = make_move(board, rows, columns, 0, 'X')[1]
           >>> print_board(new_board, rows, columns)
           - -
           X -
           """
           "*** YOUR CODE HERE ***"
           row, connection = 0, ' '
           while row < max_rows:
               print (connection.join(board[row]))
               row += 1
     #+end_src 
     - ~print(object)~ automatically line break
     - ~str.join(sequence)~  
**** Q14: Checking for victory
     #+begin_src python :results output
       def check_win_row(board, max_rows, max_cols, num_connect, row, player):
           """ Returns True if the given player has a horizontal win
           in the given row, and otherwise False.

           >>> rows, columns, num_connect = 4, 4, 2
           >>> board = create_board(rows, columns)
           >>> board = make_move(board, rows, columns, 0, 'X')[1]
           >>> board = make_move(board, rows, columns, 0, 'O')[1]
           >>> check_win_row(board, rows, columns, num_connect, 3, 'O')
           False
           >>> board = make_move(board, rows, columns, 2, 'X')[1]
           >>> board = make_move(board, rows, columns, 0, 'O')[1]
           >>> check_win_row(board, rows, columns, num_connect, 3, 'X')
           False
           >>> board = make_move(board, rows, columns, 1, 'X')[1]
           >>> check_win_row(board, rows, columns, num_connect, 3, 'X')
           True
           >>> check_win_row(board, rows, columns, 4, 3, 'X')    # A win depends on the value of num_connect
           False
           >>> check_win_row(board, rows, columns, num_connect, 3, 'O')   # We only detect wins for the given player
           False
           """
           "*** YOUR CODE HERE ***"
           if row >= 0 and row < max_rows:
               # return sum([1 for i in board[row] if i == player]) >= num_connect
               return num_connect * player in ''.join(board[row])
           else:
               return False

       def check_win_column(board, max_rows, max_cols, num_connect, col, player):
           """ Returns True if the given player has a vertical win in the given column,
           and otherwise False.

           >>> rows, columns, num_connect = 5, 5, 2
           >>> board = create_board(rows, columns)
           >>> board = make_move(board, rows, columns, 0, 'X')[1]
           >>> board = make_move(board, rows, columns, 1, 'O')[1]
           >>> check_win_column(board, rows, columns, num_connect, 0, 'X')
           False
           >>> board = make_move(board, rows, columns, 1, 'X')[1]
           >>> board = make_move(board, rows, columns, 1, 'O')[1]
           >>> check_win_column(board, rows, columns, num_connect, 1, 'O')
           False
           >>> board = make_move(board, rows, columns, 2, 'X')[1]
           >>> board = make_move(board, rows, columns, 1, 'O')[1]
           >>> check_win_column(board, rows, columns, num_connect, 1, 'O')
           True
           >>> check_win_column(board, rows, columns, 4, 1, 'O')
           False
           >>> check_win_column(board, rows, columns, num_connect, 1, 'X')
           False
           """
           "*** YOUR CODE HERE ***"
           if col >= 0 and col < max_cols:
               return num_connect * player in ''.join(list(zip(*board))[col])
           else:
               return False
     #+end_src 
     - ~[a] * 3~ = ~[a, a, a]~, ~'a' * 3~ = ~'aaa'~, ~'aaa' in 'aaabaa'~ = ~True~   
     - ~''.join(['a','b'])~ = ~''.join(('a','b'))~ = ~'ab'~
     - ~list(zip(*[[1,2],[3,4]]))~ = ~[(1,3), (2,4)]~,    
     - ~num_connect * player in ''.join(board[row])~ and ~num_connect * player in ''.join(list(zip(*board))[col])~ 
**** Question                                                     :QUESTIONS:
     1. 关于Connect N整个程序的函数和数据抽象思想进一步思考
        
* Lab 5 Python Lists, Trees 
** Required Questions
   #+begin_src python :results output
     # Tree ADT
     def tree(label, branches=[]):
         """Construct a tree with the given label value and a list of branches."""
         for branch in branches:
             assert is_tree(branch), 'branches must be trees'
         return [label] + list(branches)

     def label(tree):
         """Return the label value of a tree."""
         return tree[0]

     def branches(tree):
         """Return the list of branches of the given tree."""
         return tree[1:]

     def is_tree(tree):
         """Returns True if the given tree is a tree, and False otherwise."""
         if type(tree) != list or len(tree) < 1:
             return False
         for branch in branches(tree):
             if not is_tree(branch):
                 return False
         return True

     def is_leaf(tree):
         """Returns True if the given tree's list of branches is empty, and False
         otherwise.
         """
         return not branches(tree)

     def print_tree(t, indent=0):
         """Print a representation of this tree in which each node is
         indented by two spaces times its depth from the root.

         >>> print_tree(tree(1))
         1
         >>> print_tree(tree(1, [tree(2)]))
         1
           2
         >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])
         >>> print_tree(numbers)
         1
           2
           3
             4
             5
           6
             7
         """
         print('  ' * indent + str(label(t)))
         for b in branches(t):
             print_tree(b, indent + 1)

     def copy_tree(t):
         """Returns a copy of t. Only for testing purposes.

         >>> t = tree(5)
         >>> copy = copy_tree(t)
         >>> t = tree(6)
         >>> print_tree(copy)
         5
         """
         return tree(label(t), [copy_tree(b) for b in branches(t)])
   #+end_src 
*** Q1: Acorn Finder
    #+begin_src python :results output
      def acorn_finder(t):
          """Returns True if t contains a node with the value 'acorn' and
          False otherwise.

          >>> scrat = tree('acorn')
          >>> acorn_finder(scrat)
          True
          >>> sproul = tree('roots', [tree('branch1', [tree('leaf'), tree('acorn')]), tree('branch2')])
          >>> acorn_finder(sproul)
          True
          >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])
          >>> acorn_finder(numbers)
          False
          """
          "*** YOUR CODE HERE ***"
          result = False
          if is_leaf(t):
              return label(t) == 'acorn'
          if label(t) == 'acorn':
              return True
          else:
              for branch in branches(t):
                  result = result or acorn_finder(branch)
                  if result:
                      return True
              return result
    #+end_src 
    - ~result = False~ and ~result = result or acorn_finder(branch)~
    - Recursion in iteration
*** Q2: Pruning Leaves
    #+begin_src python :results output
      def prune_leaves(t, vals):
          """Return a modified copy of t with all leaves that have a label
          that appears in vals removed.  Return None if the entire tree is
          pruned away.

          >>> t = tree(2)
          >>> print(prune_leaves(t, (1, 2)))
          None
          >>> numbers = tree(1, [tree(2), tree(3, [tree(4), tree(5)]), tree(6, [tree(7)])])
          >>> print_tree(numbers)
          1
            2
            3
              4
              5
            6
              7
          >>> print_tree(prune_leaves(numbers, (3, 4, 6, 7)))
          1
            2
            3
              5
            6
          """
          "*** YOUR CODE HERE ***"
          prune_t = [label(t)]
          if is_leaf(t):
              return None if label(t) in vals else t
          else:
              for i in branches(t):
                  if prune_leaves(i, vals):
                      prune_t.append(prune_leaves(i, vals))
                      # or prune_t += [prune_leaves(i, vals)]
              return prune_t
    #+end_src 
    - ~prune_t = [label(t)]~ 
    - ~prune_t.append(prune_leaves(i, vals))~ if ~prune_leaves(i, vals)~ is not ~None~
    - ~list += [...] = ~list.append(...)~ = ~list.extend([...])~ (while ~append~ and ~extend~ are mutable operations, ~+~ creates a new list)
*** Q3: Memory
    #+begin_src python :results output
      def memory(n):
          """
          >>> f = memory(10)
          >>> f(lambda x: x * 2)
          20
          >>> f(lambda x: x - 7)
          13
          >>> f(lambda x: x > 5)
          True
          """
          "*** YOUR CODE HERE ***"
          def f(g):
              nonlocal n
              n = g(n)
              return n
          return f
    #+end_src 
    - ~nonlocal n~ and ~n = g(n)~ 
*** Question:                                                     :QUESTIONS:
    1. 关于 recursion in iteration，这么写规范吗？能否用纯 iteration 或 recursion 改写？能不能有什么本质原因？（什么样的问题必须用 recursion in iteration才能比较好的解决？）
    2. 有没有 iteration in recursion？同1疑问
** Optional Questions
*** Shakespeare and Dictionaries
**** Q4: Successor Tables
     #+begin_src python :results output
       def build_successors_table(tokens):
           """Return a dictionary: keys are words; values are lists of successors.

           >>> text = ['We', 'came', 'to', 'investigate', ',', 'catch', 'bad', 'guys', 'and', 'to', 'eat', 'pie', '.']
           >>> table = build_successors_table(text)
           >>> sorted(table)
           [',', '.', 'We', 'and', 'bad', 'came', 'catch', 'eat', 'guys', 'investigate', 'pie', 'to']
           >>> table['to']
           ['investigate', 'eat']
           >>> table['pie']
           ['.']
           >>> table['.']
           ['We']
           """
           table = {}
           prev = '.'
           for word in tokens:
               if prev not in table:
                   "*** YOUR CODE HERE ***"
                   table[prev] = [word]
               else:
                   table[prev].append(word)
               "*** YOUR CODE HERE ***"
               prev = word
           return table
     #+end_src 
     - ~prev = '.'~ with ~for word in tokens~ or ~prev = tokens[0]~ with ~for word in tokens.append(tokens[0])~, then ~prev = word~ in the *final* of each iteration to get *two adjacent elements* in ~tokens~ as ~[prev, word]~
     - ~table[prev] = [word]~ and ~table[prev].append(word)~ 
**** Q5: Construct the Sentence
     #+begin_src python :results output
       def construct_sent(word, table):
           """Prints a random sentence starting with word, sampling from
           table.

           >>> table = {'Wow': ['!'], 'Sentences': ['are'], 'are': ['cool'], 'cool': ['.']}
           >>> construct_sent('Wow', table)
           'Wow!'
           >>> construct_sent('Sentences', table)
           'Sentences are cool.'
           """
           import random
           result = ''
           while word not in ['.', '!', '?']:
               "*** YOUR CODE HERE ***"
               result = result + word + ' '
               word = random.choice(table[word])
           return result.strip() + word
     #+end_src 
     - ~while word not in ['.', '!', '?']~
     - ~result = result + word + ' '~ and ~word = random.choice(table[word])~
     - ~' a b c '.strip()~ = ~'a b c'~ 
     Putting it all together
     #+begin_src python :results output
       def shakespeare_tokens(path='shakespeare.txt', url='http://composingprograms.com/shakespeare.txt'):
           """Return the words of Shakespeare's plays as a list."""
           import os
           from urllib.request import urlopen
           if os.path.exists(path):
               return open('shakespeare.txt', encoding='ascii').read().split()
           else:
               shakespeare = urlopen(url)
               return shakespeare.read().decode(encoding='ascii').split()

       # Uncomment the following two lines
       tokens = shakespeare_tokens()
       table = build_successors_table(tokens)

       def random_sent():
           import random
           return construct_sent(random.choice(table['.']), table)
     #+end_src 
**** Question:                                                   :QUESTIONS:
     1. Q4中如果要取满足某种条件的3个相邻元素呢？有何一般方法？
*** More Trees Practice
**** Q6: Sprout leaves
     #+begin_src python :results output
       def sprout_leaves(t, vals):
           """Sprout new leaves containing the data in vals at each leaf in
           the original tree t and return the resulting tree.

           >>> t1 = tree(1, [tree(2), tree(3)])
           >>> print_tree(t1)
           1
             2
             3
           >>> new1 = sprout_leaves(t1, [4, 5])
           >>> print_tree(new1)
           1
             2
               4
               5
             3
               4
               5

           >>> t2 = tree(1, [tree(2, [tree(3)])])
           >>> print_tree(t2)
           1
             2
               3
           >>> new2 = sprout_leaves(t2, [6, 1, 2])
           >>> print_tree(new2)
           1
             2
               3
                 6
                 1
                 2
           """
           "*** YOUR CODE HERE ***"
           if is_leaf(t):
               for i in vals:
                   t.append([i])
               return t
           sprout_t = [label(t)]
           for branch in branches(t):
               sprout_t.append(sprout_leaves(branch, vals))
           return sprout_t
     #+end_src 
     - ~sprout_t = [label(t)]~ and ~sprout_t.append(sprout_leaves(branch, vals))~ 
**** Q7: Add trees
     #+begin_src python :results output
       def add_trees(t1, t2):
           """
           >>> numbers = tree(1,
           ...                [tree(2,
           ...                      [tree(3),
           ...                       tree(4)]),
           ...                 tree(5,
           ...                      [tree(6,
           ...                            [tree(7)]),
           ...                       tree(8)])])
           >>> print_tree(add_trees(numbers, numbers))
           2
             4
               6
               8
             10
               12
                 14
               16
           >>> print_tree(add_trees(tree(2), tree(3, [tree(4), tree(5)])))
           5
             4
             5
           >>> print_tree(add_trees(tree(2, [tree(3)]), tree(2, [tree(3), tree(4)])))
           4
             6
             4
           >>> print_tree(add_trees(tree(2, [tree(3, [tree(4), tree(5)])]), \
           tree(2, [tree(3, [tree(4)]), tree(5)])))
           4
             6
               8
               5
             5
           """
           "*** YOUR CODE HERE ***" 
           if len(t1) > len(t2):
               t2 += (len(t1) - len(t2)) * [[0]]
           else:
               t1 += (len(t2) - len(t1)) * [[0]]
           add_t = [label(t1) + label(t2)]
           if is_leaf(t1):
               return add_t
           else:
               for branch1, branch2 in zip(branches(t1), branches(t2)):
                   add_t.append(add_trees(list(branch1), list(branch2)))
               return add_t
     #+end_src 
     - ~t2 += (len(t1) - len(t2)) * [[0]]~ and ~t1 += (len(t2) - len(t1)) * [[0]]~ -> ~add_t = [label(t1) + label(t2)]~
     - ~x, y = zip([1, 2], [3, 4])~ -> 2 *tuples* ~x = (1, 3)~ and ~y = (2, 4)~
     - ~for branch1, branch2 in zip(branches(t1), branches(t2)):~ and ~add_t.append(add_trees(list(branch1), list(branch2)))~
     - In tree "recursive in iterative" func, base condition is usually ~is_leaf(t)~, recursive func usually invokes on ~branches(t)~, and final return value usually combines ~label(t)~ and *recursive result*.
**** Question:                                                    :QUESTIONS:
     1. Q7有没有更优的办法？比如不需要消耗内存补0的方法
* Lab 6 Object-Oriented Programming
  #+begin_src python :results output
    class Deck(object):
        def __init__(self, cards):
            """
            With a list of cards as input, create a deck.
            This deck should keep track of the cards it contains, and
            we should be able to draw from the deck, taking a random
            card out of it.
            """
            self.cards = cards

        def draw(self):
            """
            Draw a random card and remove it from the deck.
            """
            assert self.cards, 'The deck is empty!'
            rand_index = random.randrange(len(self.cards))
            return self.cards.pop(rand_index)

        def is_empty(self):
            return len(self.cards) == 0

        def copy(self):
            """
            Create a copy of this deck.
            """
            return Deck([card.copy() for card in self.cards])

    class Game(object):

        win_score = 8

        def __init__(self, player1, player2):
            """
            Initialize a game of <REPLACE NAME>.
            """
            self.player1, self.player2 = player1, player2
            self.p1_score = 0
            self.p2_score = 0

        def play_round(self, p1_card, p2_card):
            """
            After each player picks a card, play them against
            each other.
            """
            p1_card.effect(p2_card, self.player1, self.player2)
            p2_card.effect(p1_card, self.player2, self.player1)
            p1_power = p1_card.power(p2_card)
            p2_power = p2_card.power(p1_card)
            if p1_power > p2_power:
                # Player 1 wins the round.
                self.p1_score += 1
                result = 'won'
            elif p2_power > p1_power:
                # Player 2 wins the round.
                self.p2_score += 1
                result = 'lost'
            else:
                # This round is a draw.
                result = 'tied'
            # Display results to user.
            print('You {} this round!'.format(result))
            print('{}\'s card: {}; Power: {}'.format(self.player1.name, p1_card, p1_power))
            print('Opponent\'s card: {}; Power: {}'.format(p2_card, p2_power))


        def game_won(self):
            """
            Check if the game is won and, if so,
            which player won.
            """
            if self.p1_score < self.win_score and self.p2_score < self.win_score:
                return 0
            return 1 if self.p1_score > self.p2_score else 2

        def display_scores(self):
            """
            Display players' scores to the user.
            """
            print('{}\'s score: {}'.format(self.player1.name, self.p1_score))
            print('Opponent\'s score: {}'.format(self.p2_score))
  #+end_src 
** Required 
*** WWPD
**** Q2: Using the Car class
     #+begin_src python :results output
       class Car(object):
           num_wheels = 4
           gas = 30
           headlights = 2
           size = 'Tiny'

           def __init__(self, make, model):
               self.make = make
               self.model = model
               self.color = 'No color yet. You need to paint me.'
               self.wheels = Car.num_wheels
               self.gas = Car.gas

           def paint(self, color):
               self.color = color
               return self.make + ' ' + self.model + ' is now ' + color

           def drive(self):
               if self.wheels < Car.num_wheels or self.gas <= 0:
                   return self.make + ' ' + self.model + ' cannot drive!'
               self.gas -= 10
               return self.make + ' ' + self.model + ' goes vroom!'

           def pop_tire(self):
               if self.wheels > 0:
                   self.wheels -= 1

           def fill_gas(self):
               self.gas += 20
               return self.make + ' ' + self.model + ' gas level: ' + str(self.gas)


       class MonsterTruck(Car):
           size = 'Monster'

           def rev(self):
               print('Vroom! This Monster Truck is huge!')

           def drive(self):
               self.rev()
               return Car.drive(self)
     #+end_src 
     #+begin_src python :results output
       ---------------------------------------------------------------------
       Car > Suite 1 > Case 3

       >>> from car import *
       >>> deneros_car = Car('Tesla', 'Model S')
       >>> Car.headlights
       2
       >>> deneros_car.headlights
       2
       >>> Car.headlights = 3
       >>> deneros_car.headlights
       3
       >>> deneros_car.headlights = 2
       >>> Car.headlights
       3
       -- OK! --

       ---------------------------------------------------------------------
       Car > Suite 1 > Case 4

       >>> from car import *
       >>> deneros_car = Car('Tesla', 'Model S')
       >>> deneros_car.wheels = 2
       >>> deneros_car.wheels
       2
       >>> Car.num_wheels
       4
       >>> deneros_car.drive() # Type Error if an error occurs and Nothing if nothing is displayed
       'Tesla Model S cannot drive!'
       >>> Car.drive() # Type Error if an error occurs and Nothing if nothing is displayed
       Error
       >>> Car.drive(deneros_car) # Type Error if an error occurs and Nothing if nothing is displayed
       'Tesla Model S cannot drive!'
       -- OK! --

       ---------------------------------------------------------------------
       Car > Suite 1 > Case 5

       >>> from car import *
       >>> deneros_car = MonsterTruck('Monster', 'Batmobile')
       >>> deneros_car.drive() # Type Error if an error occurs and Nothing if nothing is displayed
       Vroom! This Monster Truck is huge!
       'Monster Batmobile goes vroom!'
       >>> Car.drive(deneros_car) # Type Error if an error occurs and Nothing if nothing is displayed
       'Monster Batmobile goes vroom!'
       >>> MonsterTruck.drive(deneros_car) # Type Error if an error occurs and Nothing if nothing is displayed
       Vroom! This Monster Truck is huge!
       'Monster Batmobile goes vroom!'
       >>> Car.rev(deneros_car) # Type Error if an error occurs and Nothing if nothing is displayed
       Error
       -- OK! --
     #+end_src 
     - ~Car.headlights~ vs ~deneros_car.headlights~
     - ~Car.num_wheels~ vs ~deneros_car.wheels~
     - ~Car.drive()~ vs ~MonsterTruck.drive()~ vs ~deneros_car.drive()~ 
*** Magic: The Lambda-ing
**** Q4: Making a Player
     #+begin_src python :results output
       class Player(object):
           def __init__(self, deck, name):
               """Initialize a Player object.
               A Player starts the game by drawing 5 cards from their deck. Each turn,
               a Player draws another card from the deck and chooses one to play.
               >>> test_card = Card('test', 100, 100)
               >>> test_deck = Deck([test_card.copy() for _ in range(6)])
               >>> test_player = Player(test_deck, 'tester')
               >>> len(test_deck.cards)
               1
               >>> len(test_player.hand)
               5
               """
               self.deck = deck
               self.name = name
               "*** YOUR CODE HERE ***"
               self.hand = [deck.draw() for _ in range(5)]

           def draw(self):
               """Draw a card from the player's deck and add it to their hand.
               >>> test_card = Card('test', 100, 100)
               >>> test_deck = Deck([test_card.copy() for _ in range(6)])
               >>> test_player = Player(test_deck, 'tester')
               >>> test_player.draw()
               >>> len(test_deck.cards)
               0
               >>> len(test_player.hand)
               6
               """
               assert not self.deck.is_empty(), 'Deck is empty!'
               "*** YOUR CODE HERE ***"
               self.hand.append(self.deck.draw())

           def play(self, card_index):
               """Remove and return a card from the player's hand at the given index.
               >>> from cards import *
               >>> test_player = Player(standard_deck, 'tester')
               >>> ta1, ta2 = TACard("ta_1", 300, 400), TACard("ta_2", 500, 600)
               >>> tutor1, tutor2 = TutorCard("t1", 200, 500), TutorCard("t2", 600, 400)
               >>> test_player.hand = [ta1, ta2, tutor1, tutor2]
               >>> test_player.play(0) is ta1 
               True
               >>> test_player.play(2) is tutor2 
               True
               >>> len(test_player.hand)
               2
               """
               "*** YOUR CODE HERE ***"
               return self.hand.pop(card_index)

           def display_hand(self):
               """
               Display the player's current hand to the user.
               """
               print('Your hand:')
               for card_index, displayed_card in zip(range(len(self.hand)),[str(card) for card in self.hand]):
                   indent = ' '*(5 - len(str(card_index)))
                   print(card_index, indent + displayed_card)

           def play_random(self):
               """
               Play a random card from hand.
               """
               return self.play(random.randrange(len(self.hand)))
     #+end_src 
     - ~self.hand = [deck.draw() for _ in range(5)]~
     - ~self.hand.append(self.deck.draw())~
     - ~self.hand.pop(card_index)~ 
** Optional Questions
*** Q5: Tutors: Flummox
    #+begin_src python :results output
      class TutorCard(Card):
          cardtype = 'Tutor'

          def effect(self, other_card, player, opponent):
              """
              Discard the first 3 cards in the opponent's hand and have
              them draw the same number of cards from their deck.
              >>> from cards import *
              >>> player1, player2 = Player(player_deck, 'p1'), Player(opponent_deck, 'p2')
              >>> other_card = Card('other', 500, 500)
              >>> tutor_test = TutorCard('Tutor', 500, 500)
              >>> initial_deck_length = len(player2.deck.cards)
              >>> tutor_test.effect(other_card, player1, player2)
              p2 discarded and re-drew 3 cards!
              >>> len(player2.hand)
              5
              >>> len(player2.deck.cards) == initial_deck_length - 3
              True
              """
              "*** YOUR CODE HERE ***"
              original_len = len(opponent.hand)
              opponent.hand = opponent.hand[3:] if len(opponent.hand) > 3 else []
              for _ in range(original_len - len(opponent.hand)):
                  opponent.draw()
              #Uncomment the line below when you've finished implementing this method!
              print('{} discarded and re-drew 3 cards!'.format(opponent.name))

          def copy(self):
              """
              Create a copy of this card.
              """
              return TutorCard(self.name, self.attack, self.defense)
    #+end_src 
    - ~opponent.hand = opponent.hand[3:] if len(opponent.hand) > 3 else []~
    - ~for _ in range(original_len - len(opponent.hand))~ 
*** Q6: TAs: Shift
    #+begin_src python :results output
      class TACard(Card):
          cardtype = 'TA'

          def effect(self, other_card, player, opponent):
              """
              Swap the attack and defense of an opponent's card.
              >>> from cards import *
              >>> player1, player2 = Player(player_deck, 'p1'), Player(opponent_deck, 'p2')
              >>> other_card = Card('other', 300, 600)
              >>> ta_test = TACard('TA', 500, 500)
              >>> ta_test.effect(other_card, player1, player2)
              >>> other_card.attack
              600
              >>> other_card.defense
              300
              """
              "*** YOUR CODE HERE ***"
              other_card.attack, other_card.defense = other_card.defense, other_card.attack


          def copy(self):
              """
              Create a copy of this card.
              """
              return TACard(self.name, self.attack, self.defense)
    #+end_src 
    - ~other_card.attack, other_card.defense = other_card.defense, other_card.attack~ 
*** Q7: The Professor Arrives
    #+begin_src python :results output
      class ProfessorCard(Card):
          cardtype = 'Professor'

          def effect(self, other_card, player, opponent):
              """
              Adds the attack and defense of the opponent's card to
              all cards in the player's deck, then removes all cards
              in the opponent's deck that share an attack or defense
              stat with the opponent's card.
              >>> test_card = Card('card', 300, 300)
              >>> professor_test = ProfessorCard('Professor', 500, 500)
              >>> opponent_card = test_card.copy()
              >>> test_deck = Deck([test_card.copy() for _ in range(8)])
              >>> player1, player2 = Player(test_deck.copy(), 'p1'), Player(test_deck.copy(), 'p2')
              >>> professor_test.effect(opponent_card, player1, player2)
              3 cards were discarded from p2's deck!
              >>> [(card.attack, card.defense) for card in player1.deck.cards]
              [(600, 600), (600, 600), (600, 600)]
              >>> len(player2.deck.cards)
              0
              """
              orig_opponent_deck_length = len(opponent.deck.cards)
              "*** YOUR CODE HERE ***"
              for card in player.deck.cards:
                  card.attack += other_card.attack
                  card.defense += other_card.defense
              opponent_deck_cards_copy = opponent.deck.cards.copy()
              for card in opponent_deck_cards_copy:
                  if card.attack == other_card.attack or card.defense == other_card.defense:
                      opponent.deck.cards.remove(card)
              discarded = orig_opponent_deck_length - len(opponent.deck.cards)
              if discarded:
                  #Uncomment the line below when you've finished implementing this method!
                  print('{} cards were discarded from {}\'s deck!'.format(discarded, opponent.name))
                  return

          def copy(self):
              return ProfessorCard(self.name, self.attack, self.defense)
    #+end_src 
    - ~opponent_deck_cards_copy = opponent.deck.cards.copy()~ and ~for card in opponent_deck_cards_copy:~ 

* Lab 7 Linked Lists, Trees 
** Required 
***  What Would Python Display?
*** Coding Practice
**** Q6: Cumulative Sum 
     #+begin_src python :results output
       def cumulative_sum(t):
           """Mutates t so that each node's label becomes the sum of all labels in
           the corresponding subtree rooted at t.

           >>> t = Tree(1, [Tree(3, [Tree(5)]), Tree(7)])
           >>> cumulative_sum(t)
           >>> t
           Tree(16, [Tree(8, [Tree(5)]), Tree(7)])
           """
           "*** YOUR CODE HERE ***"
           for branch in t.branches:
               cumulative_sum(branch)
               t.label += branch.label
     #+end_src 
     - 
**** Q7: Is BST
     #+begin_src python :results output
       def is_bst(t):
           """Returns True if the Tree t has the structure of a valid BST.

           >>> t1 = Tree(6, [Tree(2, [Tree(1), Tree(4)]), Tree(7, [Tree(7), Tree(8)])])
           >>> is_bst(t1)
           True
           >>> t2 = Tree(8, [Tree(2, [Tree(9), Tree(1)]), Tree(3, [Tree(6)]), Tree(5)])
           >>> is_bst(t2)
           False
           >>> t3 = Tree(6, [Tree(2, [Tree(4), Tree(1)]), Tree(7, [Tree(7), Tree(8)])])
           >>> is_bst(t3)
           False
           >>> t4 = Tree(1, [Tree(2, [Tree(3, [Tree(4)])])])
           >>> is_bst(t4)
           True
           >>> t5 = Tree(1, [Tree(0, [Tree(-1, [Tree(-2)])])])
           >>> is_bst(t5)
           True
           >>> t6 = Tree(1, [Tree(4, [Tree(2, [Tree(3)])])])
           >>> is_bst(t6)
           True
           >>> t7 = Tree(2, [Tree(1, [Tree(5)]), Tree(4)])
           >>> is_bst(t7)
           False
           """
           "*** YOUR CODE HERE ***"
           if len(t.branches) > 2:
               return False
           if len(t.branches) == 1:
               min = bst_min(t.branches[0])
               max = bst_max(t.branches[0])
               if t.branches[0].label > t.label:
                   if min <= t.label:
                       return False
               else:
                   if max > t.label:
                       return False
           if len(t.branches) == 2:
               max = bst_max(t.branches[0])
               min = bst_min(t.branches[1])
               if max > t.label or min <= t.label:
                   return False
           for branch in t.branches:
               if not is_bst(branch):
                   return False

           return True

       def bst_min(t):
           if t.is_leaf():
               return t.label
           min = t.label
           for branch in t.branches:
               if bst_min(branch) < min:
                   min = bst_min(branch)
           return min

       def bst_max(t):
           if t.is_leaf():
               return t.label
           max = t.label
           for branch in t.branches:
               if bst_max(branch) > max:
                   max = bst_max(branch)
           return max
     #+end_src 
     - 
**** Q8: In-order traversal
     #+begin_src python :results output
       def in_order_traversal(t):
           """
           Generator function that generates an "in-order" traversal, in which we 
           yield the value of every node in order from left to right, assuming that each node has either 0 or 2 branches.

           For example, take the following tree t:
                   1
               2       3
           4     5
                6  7

           We have the in-order-traversal 4, 2, 6, 5, 7, 1, 3

           >>> t = Tree(1, [Tree(2, [Tree(4), Tree(5, [Tree(6), Tree(7)])]), Tree(3)])
           >>> list(in_order_traversal(t))
           [4, 2, 6, 5, 7, 1, 3]
           """
           "*** YOUR CODE HERE ***"
           assert t.is_leaf() or len(t.branches) == 2, 'Each node should have either 0 or 2 branches.'
           order_list = []
           if t.is_leaf():
               return [t.label]
           # import pudb; pudb.set_trace()
           order_list += in_order_traversal(t.branches[0])
           order_list += [t.label]
           order_list += in_order_traversal(t.branches[1])
           return iter(order_list)

     #+end_src 
     - Similar to [[file:~/csnds/cs/code/61a/hws/hws.org::1008][Generate Paths]] 

