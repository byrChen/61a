* HW01: Control
** Q4: If Function vs Statement
   
   #+begin_src python :results output
     def if_function(condition, true_result, false_result):
         """Return true_result if condition is a true value, and
         false_result otherwise.

         >>> if_function(True, 2, 3)
         2
         >>> if_function(False, 2, 3)
         3
         >>> if_function(3==2, 3+2, 3-2)
         1
         >>> if_function(3>2, 3+2, 3-2)
         5
         """
         if condition:
             return true_result
         else:
             return false_result


     def with_if_statement():
         """
         >>> result = with_if_statement()
         2
         >>> print(result)
         None
         """
         if c():
             return t()
         else:
             return f()

     def with_if_function():
         """
         >>> result = with_if_function()
         1
         2
         >>> print(result)
         None
         """
         return if_function(c(), t(), f())

     def c():
         "*** YOUR CODE HERE ***"
         return False

     def t():
         "*** YOUR CODE HERE ***"
         print(1)
         return None

     def f():
         "*** YOUR CODE HERE ***"
         print(2)
         return None
   #+end_src 

   1. ~with_if_statement~ prints ~2~ while ~with_if_function~ prints both ~1~ and ~2~.
** Q5: Hailstone

   #+begin_src python :results output
     def hailstone(n):
         """Print the hailstone sequence starting at n and return its
         length.

         >>> a = hailstone(10)
         10
         5
         16
         8
         4
         2
         1
         >>> a
         7
         """
         "*** YOUR CODE HERE ***"
         a = 1
         while n != 1:
             print(n)
             if n % 2 == 0:
                 n //= 2
             else:
                 n = n*3 + 1
             a += 1
         print(1)
         return a
   #+end_src 

   1. Hailstone sequence.
** Q6: Quine

* HW02: Higher Order Functions
** Q1: Make Adder with a Lambda

   #+begin_src python :results output
     def make_adder(n):
         """Return a function that takes an argument K and returns N + K.

         >>> add_three = make_adder(3)
         >>> add_three(1) + add_three(2)
         9
         >>> make_adder(1)(2)
         3
         """
         return lambda k: n + k

     def make_adder1(n):
         def inner(k):
             return n + k
         return inner
   #+end_src 

   1. ~lambda args: expression~.
   2. ~make_adder(1)(2)~. 

** Q3: Accumulate 

   #+begin_src python :results output
     def accumulate(combiner, base, n, term):
         """Return the result of combining the first n terms in a sequence and base.
         The terms to be combined are term(1), term(2), ..., term(n).  combiner is a
         two-argument commutative, associative function.

         >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
         15
         >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
         26
         >>> accumulate(add, 11, 0, identity) # 11
         11
         >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
         25
         >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
         72
         """
         "*** YOUR CODE HERE ***"
         result, i = base, 1
         while i <= n:
             result, i = combiner(result, term(i)), i + 1
         return result

     def accumulate2(combiner, base, n, term):
         if n == 0:
             return base
         return combiner(term(n), accumulate2(combiner, base, n-1, term))

     def accumulate3(combiner, base, n, term):
         if n == 0:
             return base
         return accumulate3(combiner, combiner(base, term(n)), n-1, term)

     def summation_using_accumulate(n, term):
         """Returns the sum of term(1) + ... + term(n). The implementation
         uses accumulate.

         >>> summation_using_accumulate(5, square)
         55
         >>> summation_using_accumulate(5, triple)
         45
         >>> from construct_check import check
         >>> check(HW_SOURCE_FILE, 'summation_using_accumulate',
         ...       ['Recursion', 'For', 'While'])
         True
         """
         "*** YOUR CODE HERE ***"
         return accumulate(add, 0, n, term)

     def product_using_accumulate(n, term):
         """An implementation of product using accumulate.

         >>> product_using_accumulate(4, square)
         576
         >>> product_using_accumulate(6, triple)
         524880
         >>> from construct_check import check
         >>> check(HW_SOURCE_FILE, 'product_using_accumulate',
         ...       ['Recursion', 'For', 'While'])
         True
         """
         "*** YOUR CODE HERE ***"
         return accumulate(mul, 1, n, term)
   #+end_src 

   1. *Loop method*: ~combiner(combiner(...combiner(base, term(1))..., term(n-1)), term(n))~.
   2. *Recursive method*:
      - ~accumulate2~: treat ~combiner(...combiner(base, term(1))..., term(n-1))~ as ~accumulate2(combiner, base, n-1, term)~ and ~return combiner(term(n), accumulate2(combiner, base, n-1, term)~.    
      - ~accumulate3~: treat ~combiner(base, term(n))~ as ~base~ and ~return accumulate3(combiner, combiner(base, term(n)), n-1, term)~.    
   3. ~return accumulate(add, 0, n, term)~ and ~return accumulate(mul, 1, n, term)~.
** Q4: Make Repeater

   #+begin_src python :results output
     def compose1(f, g):
         """Return a function h, such that h(x) = f(g(x))."""
         def h(x):
             return f(g(x))
         return h

     def make_repeater(f, n):
         """Return the function that computes the nth application of f.

         >>> add_three = make_repeater(increment, 3)
         >>> add_three(5)
         8
         >>> make_repeater(triple, 5)(1) # 3 * 3 * 3 * 3 * 3 * 1
         243
         >>> make_repeater(square, 2)(5) # square(square(5))
         625
         >>> make_repeater(square, 4)(5) # square(square(square(square(5))))
         152587890625
         >>> make_repeater(square, 0)(5)
         5
         """
         "*** YOUR CODE HERE ***"
         def g(x, t = f, m = n):
             if m == 0:
                 return x
             else:
                 m -= 1
                 return t(g(x, t, m))
         return g

     def make_repeater2(f, n):
         g = identity
         while n > 0:
             g = compose1(f, g)
             n = n - 1
         return g

     def make_repeater3(f, n):
         def h(x):
             k = 0
             while k < n:
                 x, k = f(x), k + 1
             return x
         return h

     def make_repeater4(f, n):
         if n == 0:
             return lambda x: x
         return lambda x: f(make_repeater3(f, n - 1)(x))

     def make_repeater5(f, n):
         if n == 0:
             return lambda x: x
         return compose1(f, make_repeater4(f, n - 1))

     def make_repeater6(f, n):
         return accumulate(compose1, lambda x: x, n, lambda k: f)

   #+end_src 
