* HW01: Control
** Q4: If Function vs Statement
   
   #+begin_src python :results output
     def if_function(condition, true_result, false_result):
         """Return true_result if condition is a true value, and
         false_result otherwise.

         >>> if_function(True, 2, 3)
         2
         >>> if_function(False, 2, 3)
         3
         >>> if_function(3==2, 3+2, 3-2)
         1
         >>> if_function(3>2, 3+2, 3-2)
         5
         """
         if condition:
             return true_result
         else:
             return false_result


     def with_if_statement():
         """
         >>> result = with_if_statement()
         2
         >>> print(result)
         None
         """
         if c():
             return t()
         else:
             return f()

     def with_if_function():
         """
         >>> result = with_if_function()
         1
         2
         >>> print(result)
         None
         """
         return if_function(c(), t(), f())

     def c():
         "*** YOUR CODE HERE ***"
         return False

     def t():
         "*** YOUR CODE HERE ***"
         print(1)
         return None

     def f():
         "*** YOUR CODE HERE ***"
         print(2)
         return None
   #+end_src 

   1. ~with_if_statement~ prints ~2~ while ~with_if_function~ prints both ~1~ and ~2~.
** Q5: Hailstone

   #+begin_src python :results output
     def hailstone(n):
         """Print the hailstone sequence starting at n and return its
         length.

         >>> a = hailstone(10)
         10
         5
         16
         8
         4
         2
         1
         >>> a
         7
         """
         "*** YOUR CODE HERE ***"
         a = 1
         while n != 1:
             print(n)
             if n % 2 == 0:
                 n //= 2
             else:
                 n = n*3 + 1
             a += 1
         print(1)
         return a
   #+end_src 

   1. Hailstone sequence.
** Q6: Quine
* HW02: Higher Order Functions
** Q1: Make Adder with a Lambda

   #+begin_src python :results output
     def make_adder(n):
         """Return a function that takes an argument K and returns N + K.

         >>> add_three = make_adder(3)
         >>> add_three(1) + add_three(2)
         9
         >>> make_adder(1)(2)
         3
         """
         return lambda k: n + k

     def make_adder1(n):
         def inner(k):
             return n + k
         return inner
   #+end_src 

   1. ~lambda args: expression~.
   2. ~make_adder(1)(2)~. 

** Q3: Accumulate 

   #+begin_src python :results output
     def accumulate(combiner, base, n, term):
         """Return the result of combining the first n terms in a sequence and base.
         The terms to be combined are term(1), term(2), ..., term(n).  combiner is a
         two-argument commutative, associative function.

         >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
         15
         >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
         26
         >>> accumulate(add, 11, 0, identity) # 11
         11
         >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
         25
         >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
         72
         """
         "*** YOUR CODE HERE ***"
         result, i = base, 1
         while i <= n:
             result, i = combiner(result, term(i)), i + 1
         return result

     def accumulate2(combiner, base, n, term):
         if n == 0:
             return base
         return combiner(term(n), accumulate2(combiner, base, n-1, term))

     def accumulate3(combiner, base, n, term):
         if n == 0:
             return base
         return accumulate3(combiner, combiner(base, term(n)), n-1, term)

     def summation_using_accumulate(n, term):
         """Returns the sum of term(1) + ... + term(n). The implementation
         uses accumulate.

         >>> summation_using_accumulate(5, square)
         55
         >>> summation_using_accumulate(5, triple)
         45
         >>> from construct_check import check
         >>> check(HW_SOURCE_FILE, 'summation_using_accumulate',
         ...       ['Recursion', 'For', 'While'])
         True
         """
         "*** YOUR CODE HERE ***"
         return accumulate(add, 0, n, term)

     def product_using_accumulate(n, term):
         """An implementation of product using accumulate.

         >>> product_using_accumulate(4, square)
         576
         >>> product_using_accumulate(6, triple)
         524880
         >>> from construct_check import check
         >>> check(HW_SOURCE_FILE, 'product_using_accumulate',
         ...       ['Recursion', 'For', 'While'])
         True
         """
         "*** YOUR CODE HERE ***"
         return accumulate(mul, 1, n, term)
   #+end_src 

   1. *Loop method*: ~combiner(combiner(...combiner(term(1), base)..., term(n-1)), term(n))~.
   2. *Recursive method*:
      - ~accumulate2~: treat ~combiner(...combiner(base, term(1))..., term(n-1))~ as ~accumulate2(combiner, base, n-1, term)~ and ~return combiner(term(n), accumulate2(combiner, base, n-1, term)~.    
      - ~accumulate3~: treat ~combiner(base, term(n))~ as ~base~ and ~return accumulate3(combiner, combiner(base, term(n)), n-1, term)~.    
   3. ~return accumulate(add, 0, n, term)~ and ~return accumulate(mul, 1, n, term)~.
** Q4: Make Repeater

   #+begin_src python :results output
     def compose1(f, g):
         """Return a function h, such that h(x) = f(g(x))."""
         def h(x):
             return f(g(x))
         return h

     def make_repeater(f, n):
         """Return the function that computes the nth application of f.

         >>> add_three = make_repeater(increment, 3)
         >>> add_three(5)
         8
         >>> make_repeater(triple, 5)(1) # 3 * 3 * 3 * 3 * 3 * 1
         243
         >>> make_repeater(square, 2)(5) # square(square(5))
         625
         >>> make_repeater(square, 4)(5) # square(square(square(square(5))))
         152587890625
         >>> make_repeater(square, 0)(5)
         5
         """
         "*** YOUR CODE HERE ***"
         def g(x, t = f, m = n):
             if m == 0:
                 return x
             else:
                 m -= 1
                 return t(g(x, t, m))
         return g

     def make_repeater2(f, n):
         g = identity
         while n > 0:
             g = compose1(f, g)
             n = n - 1
         return g

     def make_repeater3(f, n):
         def h(x):
             k = 0
             while k < n:
                 x, k = f(x), k + 1
             return x
         return h

     def make_repeater4(f, n):
         if n == 0:
             return lambda x: x
         return lambda x: f(make_repeater4(f, n - 1)(x))

     def make_repeater5(f, n):
         if n == 0:
             return lambda x: x
         return compose1(f, make_repeater5(f, n - 1))

     def make_repeater6(f, n):
         return accumulate(compose1, lambda x: x, n, lambda k: f)
   #+end_src 

   - *Loop method*: ~f(...f(f(x))...)~
     1. Non ~x~ but ~compose1~ in ~make_repeater2~: Treat ~f~ as ~f(g)~ and def ~g = identity~, use ~compose1(f, g)~ to get ~f(g)~, each iteration *change* ~g = f(g)~, finally return ~g = f(...(f(g))...)~.
     2. Non ~compose1~ but ~x~ in ~make_repeater3~: def ~h~ and return ~h~, in ~h~ *directly* return ~f(...f(f)...)~.
   - *Recursive method*
     1. Non ~compose1~ but ~x~ in ~make_repeater4~: Treat ~f(...f(f(x))...)~ as ~f(x)~ and ~x = ...f(f(x))... = make_repeater4(f, n - 1)(x)~, return ~f(x) = f(make_repeater4(f, n - 1)(x))~.
     2. Non ~x~ but ~compose1~ in ~make_repeater5~: Treat ~f(...f(f)...)~ as ~f(g)~ and ~g = ...f(f)... = make_repeater5(f, n - 1)~, return ~f(g) = compose1(f, make_repeater5(f, n - 1))~.
     3. *One line* return with ~compose1~ and ~accumulate~ in ~make_repeater6~: ~combiner~ take in *two values* and return a new *value*, while ~compose1~ take in *two funcs* and return a new *func*, ~combiner(combiner(...combiner(base, term(1))..., term(n-1)), term(n))~ = ~compose1(compose1(...compose1(x, k)..., k), k)~ = ~accumulate(compose1, lambda x: x, n, lambda k: f)~.
*** Question:
    1. 关于Loop方法，这两种思维上有何不同？是否用 ~compose1~ 加深了一层抽象？比较而言各适用于什么场景？
    2. 关于Recursive方法，第3种中所有 ~term(i)~ 为什么都等于 ~f~ ？在 ~accumulate~ 中 ~combiner~ 中的操作数可以互换，这里由于 ~compose1~ 的定义应该考虑 ~(lambda k: f, lambda x: x)~ 才对，为何实际两者仍然可以互换？这3种方法思维上有何根本不同？各适用于什么场景？
    3. 以上分析能否改进？（补充或精简统一）
       
** Q5: Church numerals

   #+begin_src python :results output
     def zero(f):
         return lambda x: x

     def successor(n):
         return lambda f: lambda x: f(n(f)(x))

     def one(f):
         """Church numeral 1: same as successor(zero)"""
         "*** YOUR CODE HERE ***"
         return lambda x: f(x)

     def two(f):
         """Church numeral 2: same as successor(successor(zero))"""
         "*** YOUR CODE HERE ***"
         return lambda x: f(f(x))

     three = successor(two)

     def church_to_int(n):
         """Convert the Church numeral n to a Python integer.

         >>> church_to_int(zero)
         0
         >>> church_to_int(one)
         1
         >>> church_to_int(two)
         2
         >>> church_to_int(three)
         3
         """
         "*** YOUR CODE HERE ***"
         return n(lambda x: x + 1)(0)

     def add_church(m, n):
         """Return the Church numeral for m + n, for Church numerals m and n.

         >>> church_to_int(add_church(two, three))
         5
         """
         "*** YOUR CODE HERE ***"
         return lambda f: lambda x: m(f)(n(f)(x))

     def mul_church(m, n):
         """Return the Church numeral for m * n, for Church numerals m and n.

         >>> four = successor(three)
         >>> church_to_int(mul_church(two, three))
         6
         >>> church_to_int(mul_church(three, four))
         12
         """
         "*** YOUR CODE HERE ***"
         return lambda f: m(n(f))

     def pow_church(m, n):
         """Return the Church numeral m ** n, for Church numerals m and n.

         >>> church_to_int(pow_church(two, three))
         8
         >>> church_to_int(pow_church(three, two))
         9
         """
         "*** YOUR CODE HERE ***"
         return n(m)
   #+end_src 

   1. f
   2. 

*** Question:
    1. 怎么理解这种思路？这种问题与这种问题的解法的特点？与high order func联系起来，是否能从多级order或者说多层抽象来思考？
