#+TAGS: UNRESOLVED(u) QUESTIONS(q) EXTRA(e) REQUIRED(r) TOBEORG(t)
* HW01
** Required                                                        :REQUIRED:
*** Q4: If Function vs Statement
   
    #+begin_src python :results output
      def if_function(condition, true_result, false_result):
          """Return true_result if condition is a true value, and
          false_result otherwise.

          >>> if_function(True, 2, 3)
          2
          >>> if_function(False, 2, 3)
          3
          >>> if_function(3==2, 3+2, 3-2)
          1
          >>> if_function(3>2, 3+2, 3-2)
          5
          """
          if condition:
              return true_result
          else:
              return false_result


      def with_if_statement():
          """
          >>> result = with_if_statement()
          2
          >>> print(result)
          None
          """
          if c():
              return t()
          else:
              return f()

      def with_if_function():
          """
          >>> result = with_if_function()
          1
          2
          >>> print(result)
          None
          """
          return if_function(c(), t(), f())

      def c():
          "*** YOUR CODE HERE ***"
          return False

      def t():
          "*** YOUR CODE HERE ***"
          print(1)

      def f():
          "*** YOUR CODE HERE ***"
          print(2)
    #+end_src 

    1. ~with_if_statement~ prints ~2~ while ~with_if_function~ prints both ~1~ and ~2~.
*** Q5: Hailstone

    #+begin_src python :results output
      def hailstone(n):
          """Print the hailstone sequence starting at n and return its
          length.

          >>> a = hailstone(10)
          10
          5
          16
          8
          4
          2
          1
          >>> a
          7
          """
          "*** YOUR CODE HERE ***"
          a = 1
          while n != 1:
              print(n)
              if n % 2 == 0:
                  n //= 2
              else:
                  n = n*3 + 1
              a += 1
          print(1)
          return a
    #+end_src 

    1. Hailstone sequence.

** Extra                                                              :EXTRA:
*** Q6: Quine
   
    #+begin_src python :results output
      s = 'print("s = " + repr(s) + "; eval(s)")'; eval(s)
    #+end_src 

    #+RESULTS:
    : s = 'print("s = " + repr(s) + "; eval(s)")'; eval(s)
    
    - ~repr(object)~ vs ~str(object)~
      - ~str()~ is used for creating output for *end user* while ~repr()~ is mainly used for *debugging and development*. ~repr~ ’s goal is to be *unambiguous* and ~str~ ’s is to be *readable*. For example, if we suspect a float has a *small rounding error*, ~repr~ will show us while ~str~ may not.
      - ~repr()~ compute the *“official”* string representation of an *object* (a representation that has *all information* about the abject) and ~str()~ is used to compute the *“informal”* string representation of an *object* (a representation that is *useful for printing* the object).
      - The ~print~ statement and ~str()~ built-in function uses ~__str__~ to display the string representation of the object while the ~repr()~ built-in function uses ~__repr__~ to display the object.
       
      #+begin_src python :results output
        import datetime 
        today = datetime.datetime.now() 
        # Prints readable format for date-time object 
        print(str(today))

        # prints the official format of date-time object 
        print(repr(today))
      #+end_src 

      #+RESULTS:
      : 2019-04-22 19:36:13.823131
      : datetime.datetime(2019, 4, 22, 19, 36, 13, 823131)

    - ~eval(expression, globals=None, locals=None)~
      - ~expression~: this *string* is *parsed and evaluated* as a Python expression
      - ~globals~ (optional): a *dictionary* to specify the available *global methods and variables*
      - ~locals~ (optional): another *dictionary* to specify the available *local methods and variables* 
**** Question:                                                    :QUESTIONS:
     1. 关于quine程序的原理的理解？结合上面例子。
* HW02
** Required                                                        :REQUIRED:
*** Q1: Make Adder with a Lambda

    #+begin_src python :results output
      def make_adder(n):
          """Return a function that takes an argument K and returns N + K.

          >>> add_three = make_adder(3)
          >>> add_three(1) + add_three(2)
          9
          >>> make_adder(1)(2)
          3
          """
          return lambda k: n + k

      def make_adder1(n):
          def inner(k):
              return n + k
          return inner
    #+end_src 

    1. ~lambda args: expression~.
    2. ~make_adder(1)(2)~. 

*** Q3: Accumulate 

    #+begin_src python :results output
      def accumulate(combiner, base, n, term):
          """Return the result of combining the first n terms in a sequence and base.
          The terms to be combined are term(1), term(2), ..., term(n).  combiner is a
          two-argument commutative, associative function.

          >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
          15
          >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
          26
          >>> accumulate(add, 11, 0, identity) # 11
          11
          >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
          25
          >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
          72
          """
          "*** YOUR CODE HERE ***"
          result, i = base, 1
          while i <= n:
              result, i = combiner(result, term(i)), i + 1
          return result

      def accumulate2(combiner, base, n, term):
          if n == 0:
              return base
          return combiner(term(n), accumulate2(combiner, base, n-1, term))

      def accumulate3(combiner, base, n, term):
          if n == 0:
              return base
          return accumulate3(combiner, combiner(base, term(n)), n-1, term)

      def summation_using_accumulate(n, term):
          """Returns the sum of term(1) + ... + term(n). The implementation
          uses accumulate.

          >>> summation_using_accumulate(5, square)
          55
          >>> summation_using_accumulate(5, triple)
          45
          >>> from construct_check import check
          >>> check(HW_SOURCE_FILE, 'summation_using_accumulate',
          ...       ['Recursion', 'For', 'While'])
          True
          """
          "*** YOUR CODE HERE ***"
          return accumulate(add, 0, n, term)

      def product_using_accumulate(n, term):
          """An implementation of product using accumulate.

          >>> product_using_accumulate(4, square)
          576
          >>> product_using_accumulate(6, triple)
          524880
          >>> from construct_check import check
          >>> check(HW_SOURCE_FILE, 'product_using_accumulate',
          ...       ['Recursion', 'For', 'While'])
          True
          """
          "*** YOUR CODE HERE ***"
          return accumulate(mul, 1, n, term)
    #+end_src 

    1. *Loop method*: ~combiner(combiner(...combiner(term(1), base)..., term(n-1)), term(n))~.
    2. *Recursive method*:
       - ~accumulate2~: treat ~combiner(...combiner(base, term(1))..., term(n-1))~ as ~accumulate2(combiner, base, n-1, term)~ and ~return combiner(term(n), accumulate2(combiner, base, n-1, term)~.    
       - ~accumulate3~: treat ~combiner(base, term(n))~ as ~base~ and ~return accumulate3(combiner, combiner(base, term(n)), n-1, term)~.    
    3. ~return accumulate(add, 0, n, term)~ and ~return accumulate(mul, 1, n, term)~.
** Extra                                                              :EXTRA:
*** Q4: Make Repeater

    #+begin_src python :results output
      def compose1(f, g):
          """Return a function h, such that h(x) = f(g(x))."""
          def h(x):
              return f(g(x))
          return h

      def make_repeater(f, n):
          """Return the function that computes the nth application of f.

          >>> add_three = make_repeater(increment, 3)
          >>> add_three(5)
          8
          >>> make_repeater(triple, 5)(1) # 3 * 3 * 3 * 3 * 3 * 1
          243
          >>> make_repeater(square, 2)(5) # square(square(5))
          625
          >>> make_repeater(square, 4)(5) # square(square(square(square(5))))
          152587890625
          >>> make_repeater(square, 0)(5)
          5
          """
          "*** YOUR CODE HERE ***"
          def g(x, t = f, m = n):
              if m == 0:
                  return x
              else:
                  m -= 1
                  return t(g(x, t, m))
          return g
      """ solutions """
      def make_repeater2(f, n):
          g = identity
          while n > 0:
              g = compose1(f, g)
              n = n - 1
          return g

      def make_repeater3(f, n):
          def h(x):
              k = 0
              while k < n:
                  x, k = f(x), k + 1
              return x
          return h

      def make_repeater4(f, n):
          if n == 0:
              return lambda x: x
          return lambda x: f(make_repeater4(f, n - 1)(x))

      def make_repeater5(f, n):
          if n == 0:
              return lambda x: x
          return compose1(f, make_repeater5(f, n - 1))

      def make_repeater6(f, n):
          return accumulate(compose1, lambda x: x, n, lambda k: f)
    #+end_src 

    - *Iterative method*: ~f(...f(f(x))...)~
      1. Non ~x~ but ~compose1~ in ~make_repeater2~: Treat ~f~ as ~f(g)~ and def ~g = identity~, use ~compose1(f, g)~ to get ~f(g)~, each iteration *change* ~g = f(g)~, finally return ~g = f(...(f(g))...)~.
      2. Non ~compose1~ but ~x~ in ~make_repeater3~: def ~h~ and return ~h~, in ~h~ *directly* return ~f(...f(f)...)~.
    - *Recursive method*
      1. Non ~compose1~ but ~x~ in ~make_repeater4~: Treat ~f(...f(f(x))...)~ as ~f(x)~ and ~x = ...f(f(x))... = make_repeater4(f, n - 1)(x)~, return ~f(x) = f(make_repeater4(f, n - 1)(x))~.
      2. Non ~x~ but ~compose1~ in ~make_repeater5~: Treat ~f(...f(f)...)~ as ~f(g)~ and ~g = ...f(f)... = make_repeater5(f, n - 1)~, return ~f(g) = compose1(f, make_repeater5(f, n - 1))~.
      3. *One line* return with ~compose1~ and ~accumulate~ in ~make_repeater6~: ~combiner~ take in *two values* and return a new *value*, while ~compose1~ take in *two funcs* and return a new *func*, ~combiner(combiner(...combiner(base, term(1))..., term(n-1)), term(n))~ = ~compose1(compose1(...compose1(x, k)..., k), k)~ = ~accumulate(compose1, lambda x: x, n, lambda k: f)~.
**** Question:
     1. 关于Loop方法，这两种思维上有何不同？是否用 ~compose1~ 加深了一层抽象？比较而言各适用于什么场景？
     2. 关于Recursive方法，第3种中所有 ~term(i)~ 为什么都等于 ~f~ ？在 ~accumulate~ 中 ~combiner~ 中的操作数可以互换，这里由于 ~compose1~ 的定义应该考虑 ~(lambda k: f, lambda x: x)~ 才对，为何实际两者仍然可以互换？这3种方法思维上有何根本不同？各适用于什么场景？
     3. 以上分析能否改进？（补充或精简统一）
*** Q5: Church numerals
    #+begin_src python :results output
      def zero(f):
          return lambda x: x

      def successor(n):
          return lambda f: lambda x: f(n(f)(x))

      def one(f):
          """Church numeral 1: same as successor(zero)"""
          "*** YOUR CODE HERE ***"
          return lambda x: f(x)

      def two(f):
          """Church numeral 2: same as successor(successor(zero))"""
          "*** YOUR CODE HERE ***"
          return lambda x: f(f(x))

      three = successor(two)

      def church_to_int(n):
          """Convert the Church numeral n to a Python integer.

          >>> church_to_int(zero)
          0
          >>> church_to_int(one)
          1
          >>> church_to_int(two)
          2
          >>> church_to_int(three)
          3
          """
          "*** YOUR CODE HERE ***"
          return n(lambda x: x + 1)(0)

      def add_church(m, n):
          """Return the Church numeral for m + n, for Church numerals m and n.

          >>> church_to_int(add_church(two, three))
          5
          """
          "*** YOUR CODE HERE ***"
          return lambda f: lambda x: m(f)(n(f)(x))

      def mul_church(m, n):
          """Return the Church numeral for m * n, for Church numerals m and n.

          >>> four = successor(three)
          >>> church_to_int(mul_church(two, three))
          6
          >>> church_to_int(mul_church(three, four))
          12
          """
          "*** YOUR CODE HERE ***"
          return lambda f: m(n(f))

      def pow_church(m, n):
          """Return the Church numeral m ** n, for Church numerals m and n.

          >>> church_to_int(pow_church(two, three))
          8
          >>> church_to_int(pow_church(three, two))
          9
          """
          "*** YOUR CODE HERE ***"
          return n(m)
    #+end_src 
**** Question:                                                    :QUESTIONS:
     1. 怎么理解这种思路？这种问题与这种问题的解法的特点？与high order func联系起来，是否能从多级order或者说多层抽象来思考？
* HW03 
** Required                                                        :REQUIRED:
*** Q2: Ping-pong
   
    #+begin_src python :results output
      def pingpong(n):
          """Return the nth element of the ping-pong sequence.

          >>> pingpong(7)
          7
          >>> pingpong(8)
          6
          >>> pingpong(15)
          1
          >>> pingpong(21)
          -1
          >>> pingpong(22)
          0
          >>> pingpong(30)
          6
          >>> pingpong(68)
          2
          >>> pingpong(69)
          1
          >>> pingpong(70)
          0
          >>> pingpong(71)
          1
          >>> pingpong(72)
          0
          >>> pingpong(100)
          2
          >>> from construct_check import check
          >>> check(HW_SOURCE_FILE, 'pingpong', ['Assign', 'AugAssign'])
          True
          """
          "*** YOUR CODE HERE ***"
          def is_change(n):
              return (has_seven(n) or n % 7 == 0)

          def is_up(n):
              if n == 1:
                  return True
              elif is_change(n):
                  return not is_up(n-1)
              else:
                  return is_up(n-1)

          if n == 1:
              return 1
          elif is_up(n-1):
              return pingpong(n-1) + 1
          else:
              return pingpong(n-1) - 1
      """ solutioins """
      def pingping_iteration(n):
          result, i = 1, 1
          is_up = True
          while i < n:
              if has_seven(i) or i % 7 == 0:
                  is_up = not is_up
              if is_up:
                  result += 1
              else:
                  result -= 1
                  i += 1
          return result

      def pingpong2(n):
          def helper(result, i, step):
              if i == n:
                  return result
              elif i % 7 == 0 or has_seven(i):
                  return helper(result - step, i + 1, -step)
              else:
                  return helper(result + step, i + 1, step)
          return helper(1, 1, 1)

      def pingpong3(n):
          def pingpong_next(x, i, step):
              if i == n:
                  return x
              return pingpong_next(x + step, i + 1, next_dir(step, i+1))

          def next_dir(step, i):
              if i % 7 == 0 or has_seven(i):
                  return -step
              return step

          return pingpong_next(1, 1, 1)

      def pingpong4(n):
          def direction(n):
              if n < 7:
                  return 1
              if (n-1) % 7 == 0 or has_seven(n-1):
                  return -1 * direction(n-1)
              return direction(n-1)

          if n <= 7:
              return n
          return direction(n) + pingpong(n-1)

    #+end_src 
   

    - Both *recursive and iterative* method can start from *1 to n* or *n to 1*
      | start to end | recursive func                   | return value  | base        | example                  |
      | 1 to n       | new defined helper func ~helper~ | ~helper(i+1)~ | ~helper(n)~ | ~pingpong2~, ~pingpong3~ |
      | n to 1       | itself ~func~                    | ~func(n-1)~   | ~func(1)~   | ~pingpong~, ~pingpong4~  |
**** Question:
     1. 关于新定义 ~helper~ 并利用它从1开始递归到n本质上不就是iterative吗？从1到n和从n到1本质上有什么区别？ 
*** Q3: Filtered Accumulate

    #+begin_src python :results output
      def accumulate(combiner, base, n, term):
          """Return the result of combining the first n terms in a sequence and base.
          The terms to be combined are term(1), term(2), ..., term(n).  combiner is a
          two-argument, associative function.

          >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
          15
          >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
          26
          >>> accumulate(add, 11, 0, identity) # 11
          11
          >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
          25
          >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
          72
          """
          total, k = base, 1
          while k <= n:
              total, k = combiner(total, term(k)), k + 1
          return total

      def filtered_accumulate(combiner, base, pred, n, term):
          """Return the result of combining the terms in a sequence of N terms
          that satisfy the predicate pred. combiner is a two-argument function.
          If v1, v2, ..., vk are the values in term(1), term(2), ..., term(N)
          that satisfy pred, then the result is
               base combiner v1 combiner v2 ... combiner vk
          (treating combiner as if it were a binary operator, like +). The
          implementation uses accumulate.

          >>> filtered_accumulate(add, 0, lambda x: True, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
          15
          >>> filtered_accumulate(add, 11, lambda x: False, 5, identity) # 11
          11
          >>> filtered_accumulate(add, 0, odd, 5, identity)   # 0 + 1 + 3 + 5
          9
          >>> filtered_accumulate(mul, 1, greater_than_5, 5, square)  # 1 * 9 * 16 * 25
          3600
          >>> # Do not use while/for loops or recursion
          >>> from construct_check import check
          >>> check(HW_SOURCE_FILE, 'filtered_accumulate',
          ...       ['While', 'For', 'Recursion'])
          True
          """
          def combine_if(x, y):
              "*** YOUR CODE HERE ***"
              if pred(y):
                  return combiner(x, y)
              else:
                  return x

          return accumulate(combine_if, base, n, term)

      def odd(x):
          return x % 2 == 1

      def greater_than_5(x):
          return x > 5
    #+end_src 

    - ~combine_if(total, term(k)~ in ~accumulate(combine_if, base, n, term)~    
* HW04
** Required                                                        :REQUIRED:
*** Q2: Squares only
    #+begin_src python :results output
      def squares(s):
          """Returns a new list containing square roots of the elements of the
          original list that are perfect squares.

          >>> seq = [8, 49, 8, 9, 2, 1, 100, 102]
          >>> squares(seq)
          [7, 3, 1, 10]
          >>> seq = [500, 30]
          >>> squares(seq)
          []
          """
          "*** YOUR CODE HERE ***"
          return [round(numpy.math.sqrt(x)) for x in s if numpy.square(round(numpy.sqrt(x))) == x]
    #+end_src 
    - ~import numpy~ first
    - ~[round(numpy.math.sqrt(x)) for x in s if numpy.square(round(numpy.sqrt(x))) == x]~ returns a ~list~
*** Q3: G function
    #+begin_src python :results output
      def g_iter(n):
          """Return the value of G(n), computed iteratively.

          >>> g_iter(1)
          1
          >>> g_iter(2)
          2
          >>> g_iter(3)
          3
          >>> g_iter(4)
          10
          >>> g_iter(5)
          22
          >>> from construct_check import check
          >>> check(HW_SOURCE_FILE, 'g_iter', ['Recursion'])
          True
          """
          "*** YOUR CODE HERE ***"
          i = 1
          g = []
          while i <= n:
              k = i - 1
              if i <= 3:
                  g.append(i)
              else:
                  g.append(g[k - 1] + 2 * g[k - 2] + 3 * g[k - 3])
                  i += 1
          return g[n - 1]
    #+end_src 
    - ~Iteration~: not ~g[k] = ...~ but ~g.append(...)~
    - Finally ~return g[n - 1]~ 

*** Q4: Count change
    #+begin_src python :results output
      def count_change(amount):
          """Return the number of ways to make change for amount.

          >>> count_change(7)
          6
          >>> count_change(10)
          14
          >>> count_change(20)
          60
          >>> count_change(100)
          9828
          >>> from construct_check import check
          >>> check(HW_SOURCE_FILE, 'count_change', ['While', 'For'])
          True
          """
          "*** YOUR CODE HERE ***"
          if amount == 1:
              return 1
          elif amount % 2 != 0:
              return count_change(amount - 1)
          else:
              return count_change(amount / 2) + count_change(amount - 1)
    #+end_src 
    - When ~amount~ is *even*, ~return count_change(amount / 2) + count_change(amount - 1)~ or ~... + count_change(amount - 2)~
**** Question:                                                    :QUESTIONS:
     1. 怎么从理论层面推导整数分解为2的幂次和的递推式？特别是偶数与前面的关系？主要从分解式中含不含1以及含奇数or偶数个1入手。
*** Q5: Towers of Hanoi
    #+begin_src python :results output
      def move_stack(n, start, end):
          """Print the moves required to move n disks on the start pole to the end
          pole without violating the rules of Towers of Hanoi.

          n -- number of disks
          start -- a pole position, either 1, 2, or 3
          end -- a pole position, either 1, 2, or 3

          There are exactly three poles, and start and end must be different. Assume
          that the start pole has at least n disks of increasing size, and the end
          pole is either empty or has a top disk larger than the top n start disks.

          >>> move_stack(1, 1, 3)
          Move the top disk from rod 1 to rod 3
          >>> move_stack(2, 1, 3)
          Move the top disk from rod 1 to rod 2
          Move the top disk from rod 1 to rod 3
          Move the top disk from rod 2 to rod 3
          >>> move_stack(3, 1, 3)
          Move the top disk from rod 1 to rod 3
          Move the top disk from rod 1 to rod 2
          Move the top disk from rod 3 to rod 2
          Move the top disk from rod 1 to rod 3
          Move the top disk from rod 2 to rod 1
          Move the top disk from rod 2 to rod 3
          Move the top disk from rod 1 to rod 3
          """
          assert 1 <= start <= 3 and 1 <= end <= 3 and start != end, "Bad start/end"
          "*** YOUR CODE HERE ***"
          intermediary = 6 - start - end
          if n == 1:
              print_move(start, end)
          elif n % 2 == 0:
              move_stack(1, start, intermediary)
              move_stack(n-1, start, end)
              move_stack(1, intermediary, end)
          else:
              move_stack(n-1, start, intermediary)
              move_stack(1, start, end)
              move_stack(n-1, intermediary, end)
          "*** simplified sol ***"
          if n % 2 == 0:
              n_step1, n_step2, n_step3 = 1, n - 1, 1
          else:
              n_step1, n_step2, n_step3 = n - 1, 1, n - 1
          if n == 1:
              print_move(start, end)
          else:
              move_stack(n_step1, start, intermediary)
              move_stack(n_step2, start, end)
              move_stack(n_step3, intermediary, end)
    #+end_src 
    - For even *recursion*: ~move_stack(1, start, intermediary)~ --> ~move_stack(n-1, start, end)~ --> ~move_stack(1, intermediary, end)~
    - For odd *recursion*: ~move_stack(n-1, start, intermediary)~ --> ~move_stack(1, start, end)~ --> ~move_stack(n-1, intermediary, end)~
**** Question:                                                    :QUESTIONS:
     1. 还能继续简化吗？
** Extra                                                              :EXTRA:
*** Q6: Anonymous factorial                                     :UNRESOLVED:
* HW05
** Required                                                        :REQUIRED:
*** Trees
**** Q1: Replace Leaf
     #+begin_src python :results output
       def replace_leaf(t, old, new):
           """Returns a new tree where every leaf value equal to old has
           been replaced with new.

           >>> yggdrasil = tree('odin',
           ...                  [tree('balder',
           ...                        [tree('thor'),
           ...                         tree('loki')]),
           ...                   tree('frigg',
           ...                        [tree('thor')]),
           ...                   tree('thor',
           ...                        [tree('sif'),
           ...                         tree('thor')]),
           ...                   tree('thor')])
           >>> laerad = copy_tree(yggdrasil) # copy yggdrasil for testing purposes
           >>> print_tree(replace_leaf(yggdrasil, 'thor', 'freya'))
           odin
             balder
               freya
               loki
             frigg
               freya
             thor
               sif
               freya
             freya
           >>> laerad == yggdrasil # Make sure original tree is unmodified
           True
           """
           "*** YOUR CODE HERE ***"
           replace_t = [label(t)]
           if is_leaf(t):
               return [new] if label(t) == old else [label(t)]
           for branch in branches(t):
               replace_t.append(replace_leaf(branch, old, new))
           return replace_t
     #+end_src 
     - Recursive: ~[label(t)]~ --> ~if is_leaf(t):~ --> ~for branch in branches(t)~ --> ~append(recursive_func(branch))~ 
*** Mobiles
**** Q2: Weights
     #+begin_src python :results output
       def mobile(left, right):
           """Construct a mobile from a left side and a right side."""
           assert is_side(left), "left must be a side"
           assert is_side(right), "right must be a side"
           return ['mobile', left, right]

       def is_mobile(m):
           """Return whether m is a mobile."""
           return type(m) == list and len(m) == 3 and m[0] == 'mobile'

       def left(m):
           """Select the left side of a mobile."""
           assert is_mobile(m), "must call left on a mobile"
           return m[1]

       def right(m):
           """Select the right side of a mobile."""
           assert is_mobile(m), "must call right on a mobile"
           return m[2]

       def side(length, mobile_or_weight):
           """Construct a side: a length of rod with a mobile or weight at the end."""
           assert is_mobile(mobile_or_weight) or is_weight(mobile_or_weight)
           return ['side', length, mobile_or_weight]

       def is_side(s):
           """Return whether s is a side."""
           return type(s) == list and len(s) == 3 and s[0] == 'side'

       def length(s):
           """Select the length of a side."""
           assert is_side(s), "must call length on a side"
           return s[1]

       def end(s):
           """Select the mobile or weight hanging at the end of a side."""
           assert is_side(s), "must call end on a side"
           return s[2]

       def weight(size):
           """Construct a weight of some size."""
           assert size > 0
           "*** YOUR CODE HERE ***"
           return ['weight', size]

       def size(w):
           """Select the size of a weight."""
           assert is_weight(w), 'must call size on a weight'
           "*** YOUR CODE HERE ***"
           return w[1]

       def is_weight(w):
           """Whether w is a weight."""
           return type(w) == list and len(w) == 2 and w[0] == 'weight'

       def examples():
           t = mobile(side(1, weight(2)),
                      side(2, weight(1)))
           u = mobile(side(5, weight(1)),
                      side(1, mobile(side(2, weight(3)),
                                     side(3, weight(2)))))
           v = mobile(side(4, t), side(2, u))
           return (t, u, v)

       def total_weight(m):
           """Return the total weight of m, a weight or mobile.

           >>> t, u, v = examples()
           >>> total_weight(t)
           3
           >>> total_weight(u)
           6
           >>> total_weight(v)
           9
           """
           if is_weight(m):
               return size(m)
           else:
               assert is_mobile(m), "must get total weight of a mobile or a weight"
               return total_weight(end(left(m))) + total_weight(end(right(m)))
     #+end_src 
**** Q3: Balanced
     #+begin_src python :results output
       def balanced(m):
           """Return whether m is balanced.

           >>> t, u, v = examples()
           >>> balanced(t)
           True
           >>> balanced(v)
           True
           >>> w = mobile(side(3, t), side(2, u))
           >>> balanced(w)
           False
           >>> balanced(mobile(side(1, v), side(1, w)))
           False
           >>> balanced(mobile(side(1, w), side(1, v)))
           False
           """
           "*** YOUR CODE HERE ***"
           result = length(left(m)) * total_weight(end(left(m))) == length(right(m)) * total_weight(end(right(m)))
           if is_mobile(end(left(m))):
               result = result and balanced(end(left(m)))
           if is_mobile(end(right(m))):
               result = result and balanced(end(right(m)))
           return result
     #+end_src 
     - ~result = result and balanced(end(left(m)))~ and ~result = result and balanced(end(right(m)))~  
**** Q4: Totals
     #+begin_src python :results output
       def totals_tree(m):
           """Return a tree representing the mobile with its total weight at the root.

           >>> t, u, v = examples()
           >>> print_tree(totals_tree(t))
           3
             2
             1
           >>> print_tree(totals_tree(u))
           6
             1
             5
               3
               2
           >>> print_tree(totals_tree(v))
           9
             3
               2
               1
             6
               1
               5
                 3
                 2
           """
           "*** YOUR CODE HERE ***"
           label_root = [total_weight(m)]
           if is_weight(m):
               return label_root
           label_root.append(totals_tree(end(left(m))))
           label_root.append(totals_tree(end(right(m))))
           return label_root
     #+end_src 
     - Recursive: ~[total_weight(m)]~ --> ~is is_weight(m)~ --> ~label_root.append(totals_tree(end(left(m))))~ and ~label_root.append(totals_tree(end(right(m))))~ 
*** Mutable functions
**** Q6: Next Fibonacci
     #+begin_src python :results output
       def make_fib():
           """Returns a function that returns the next Fibonacci number
           every time it is called.

           >>> fib = make_fib()
           >>> fib()
           0
           >>> fib()
           1
           >>> fib()
           1
           >>> fib()
           2
           >>> fib()
           3
           >>> fib2 = make_fib()
           >>> fib() + sum([fib2() for _ in range(5)])
           12
           """
           "*** YOUR CODE HERE ***"
           n1, n2 = -1, 1
           def next_fib():
               nonlocal n1, n2
               n1, n2 = n2, n1 + n2
               return n2
           return next_fib
     #+end_src 
     - ~n1, n2 = -1, 1~ and ~n1, n2 = n2, n1 + n2~ 
**** Q7: Password Protected Account
     #+begin_src python :results output
       def make_withdraw(balance, password):
           """Return a password-protected withdraw function.

           >>> w = make_withdraw(100, 'hax0r')
           >>> w(25, 'hax0r')
           75
           >>> error = w(90, 'hax0r')
           >>> error
           'Insufficient funds'
           >>> error = w(25, 'hwat')
           >>> error
           'Incorrect password'
           >>> new_bal = w(25, 'hax0r')
           >>> new_bal
           50
           >>> w(75, 'a')
           'Incorrect password'
           >>> w(10, 'hax0r')
           40
           >>> w(20, 'n00b')
           'Incorrect password'
           >>> w(10, 'hax0r')
           "Your account is locked. Attempts: ['hwat', 'a', 'n00b']"
           >>> w(10, 'l33t')
           "Your account is locked. Attempts: ['hwat', 'a', 'n00b']"
           >>> type(w(10, 'l33t')) == str
           True
           """
           "*** YOUR CODE HERE ***"
           err_password = []
           def withdraw(amount, input_password):
               nonlocal balance, err_password
               if len(err_password) == 3:
                   return "Your account is locked. Attempts: " + str(err_password)
               if input_password == password:
                   if balance >= amount:
                       balance -= amount
                       return balance
                   else:
                       return 'Insufficient funds'
               else:
                   err_password.append(input_password)
                   return 'Incorrect password'
           return withdraw
     #+end_src 
     - ~nonlocal balance, err_password~, no need for ~nonlocal password~ 
     - ~str(err_password)~ 
**** Q8: Joint Account
     #+begin_src python :results output
       def make_joint(withdraw, old_password, new_password):
           """Return a password-protected withdraw function that has joint access to
           the balance of withdraw.

           >>> w = make_withdraw(100, 'hax0r')
           >>> w(25, 'hax0r')
           75
           >>> make_joint(w, 'my', 'secret')
           'Incorrect password'
           >>> j = make_joint(w, 'hax0r', 'secret')
           >>> w(25, 'secret')
           'Incorrect password'
           >>> j(25, 'secret')
           50
           >>> j(25, 'hax0r')
           25
           >>> j(100, 'secret')
           'Insufficient funds'

           >>> j2 = make_joint(j, 'secret', 'code')
           >>> j2(5, 'code')
           20
           >>> j2(5, 'secret')
           15
           >>> j2(5, 'hax0r')
           10

           >>> j2(25, 'password')
           'Incorrect password'
           >>> j2(5, 'secret')
           "Your account is locked. Attempts: ['my', 'secret', 'password']"
           >>> j(5, 'secret')
           "Your account is locked. Attempts: ['my', 'secret', 'password']"
           >>> w(5, 'hax0r')
           "Your account is locked. Attempts: ['my', 'secret', 'password']"
           >>> make_joint(w, 'hax0r', 'hello')
           "Your account is locked. Attempts: ['my', 'secret', 'password']"
           """
           def new_withdraw(amount, input):
               return withdraw(amount, input) if input != new_password \
                   else withdraw(amount, old_password)
           check = withdraw(0, old_password)
           return new_withdraw if type(check) != str else check
     #+end_src 
     - Storing ~check = withdraw(0, old_password)~ first to call ~withdraw~ just *once*
     - ~return new_withdraw if type(check) != str else check~ and ~return withdraw(amount, input) if input != new_password else withdraw(amount, old_password)~
     - *Recursive* call: Each return result from ~make_joint~ which is a ~new_withdraw~ func can still be a *formal para* transfered to ~make_joint~ 
**** Q9: Generate Paths
     #+begin_src python :results output
       def generate_paths(t, x):
           """Yields all possible paths from the root of t to a node with the label x
           as a list.

           >>> t1 = tree(1, [tree(2, [tree(3), tree(4, [tree(6)]), tree(5)]), tree(5)])
           >>> print_tree(t1)
           1
             2
               3
               4
                 6
               5
             5
           >>> next(generate_paths(t1, 6))
           [1, 2, 4, 6]
           >>> path_to_5 = generate_paths(t1, 5)
           >>> sorted(list(path_to_5))
           [[1, 2, 5], [1, 5]]

           >>> t2 = tree(0, [tree(2, [t1])])
           >>> print_tree(t2)
           0
             2
               1
                 2
                   3
                   4
                     6
                   5
                 5
           >>> path_to_2 = generate_paths(t2, 2)
           >>> sorted(list(path_to_2))
           [[0, 2], [0, 2, 1, 2]]
           """
           "*** YOUR CODE HERE ***"
           "*** sol1 using yield ***"
           if label(t) == x:
               yield [x]
           for branch in branches(t):
               for path in generate_paths(branch, x):
                   yield [label(t)] + path
           "*** sol2 using iter() ***"
           paths = []
           if label(t) == x:
               paths.append([x])
           for branch in branches(t):
               for path in generate_paths(branch, x):
                   paths.append([label(t)] + path)
           return iter(paths)
     #+end_src 
     - Each ~branch~ has multiple paths: ~for branch in branches(t)~ and ~for path in generate_paths(branch, x)~
     - ~yield~ is a *generator func*
     - Recursive: Each ~path~ consists of ~[label(t)]~ and *one* of ~generate_paths(branch, x)~ 
** Extra                                                              :EXTRA:
*** Interval
**** Q11: Sub Interval
     #+begin_src python :results output
       def sub_interval(x, y):
           """Return the interval that contains the difference between any value in x
           and any value in y."""
           "*** YOUR CODE HERE ***"
           p1 = lower_bound(x) - lower_bound(y)
           p2 = lower_bound(x) - upper_bound(y)
           p3 = upper_bound(x) - lower_bound(y)
           p4 = upper_bound(x) - upper_bound(y)
           return interval(min(p1, p2, p3, p4), max(p1, p2, p3, p4))
     #+end_src 
     - ~return interval(min(p1, p2, p3, p4), max(p1, p2, p3, p4))~ 
**** Q12: Div Interval
     #+begin_src python :results output
       def div_interval(x, y):
           """Return the interval that contains the quotient of any value in x divided by
           any value in y. Division is implemented as the multiplication of x by the
           reciprocal of y."""
           "*** YOUR CODE HERE ***"
           assert (1/upper_bound(y)) * (1/lower_bound(y)) > 0, "dfjie"
           reciprocal_y = interval(1/upper_bound(y), 1/lower_bound(y))
           return mul_interval(x, reciprocal_y)
     #+end_src 
     - ~(1/upper_bound(y)) * (1/lower_bound(y)) > 0~
     - ~interval(1/upper_bound(y), 1/lower_bound(y))~ 
     - ~mul_interval(x, reciprocal_y)~ 
**** Q13: Par Diff
     #+begin_src python :results output
       def par1(r1, r2):
           return div_interval(mul_interval(r1, r2), add_interval(r1, r2))

       def par2(r1, r2):
           one = interval(1, 1)
           rep_r1 = div_interval(one, r1)
           rep_r2 = div_interval(one, r2)
           return div_interval(one, add_interval(rep_r1, rep_r2))

       def check_par():
           """Return two intervals that give different results for parallel resistors.

           >>> r1, r2 = check_par()
           >>> x = par1(r1, r2)
           >>> y = par2(r1, r2)
           >>> lower_bound(x) != lower_bound(y) or upper_bound(x) != upper_bound(y)
           True
           """
           r1 = interval(1, 2) # Replace this line!
           r2 = interval(1, 4) # Replace this line!
           return r1, r2
     #+end_src 
     - ~par1~ and ~par2~ 
**** Q14: Multiple References
     She says that the problem is multiple references to the same interval.
     The Multiple References Problem: a formula to compute with intervals using Alyssa's system will produce tighter error bounds if it can be written in such a form that no variable that represents an uncertain number is repeated.
     Thus, she says, par2 is a better program for parallel resistances than par1
**** Q15: Quadratic
     #+begin_src python :results output
       def quadratic(x, a, b, c):
           """Return the interval that is the range of the quadratic defined by
           coefficients a, b, and c, for domain interval x.

           >>> str_interval(quadratic(interval(0, 2), -2, 3, -1))
           '-3 to 0.125'
           >>> str_interval(quadratic(interval(1, 3), 2, -3, 1))
           '0 to 10'
           """
           "*** YOUR  CODE HERE ***"
           def f(t):
               nonlocal a, b, c
               return a * t * t + b * t + c
           lower, upper, min_or_max = lower_bound(x), upper_bound(x), -b / (2 * a)
           f_lower, f_upper, f_min_or_max = f(lower), f(upper), f(min_or_max)
           if min_or_max > upper or min_or_max < lower:
               return interval(min(f_lower, f_upper), max(f_lower, f_upper))
           return interval(min(f_lower, f_upper, f_min_or_max), max(f_lower, f_upper, f_min_or_max))
     #+end_src 
     - ~interval(min(f_lower, f_upper), max(f_lower, f_upper))~ and ~interval(min(f_lower, f_upper, f_min_or_max), max(f_lower, f_upper, f_min_or_max))~
     - ~nonlocal a, b, c~ 
* HW06
** Object Oriented Programming 
*** Q1: Next Fibonacci Object
    #+begin_src python :results output
      class Fib():
          """A Fibonacci number.

          >>> start = Fib()
          >>> start
          0
          >>> start.next()
          1
          >>> start.next().next()
          1
          >>> start.next().next().next()
          2
          >>> start.next().next().next().next()
          3
          >>> start.next().next().next().next().next()
          5
          >>> start.next().next().next().next().next().next()
          8
          >>> start.next().next().next().next().next().next() # Ensure start isn't changed
          8
          """

          "sol1 "
          def __init__(self, value=0, previous = 0):
              self.value = value
              self.previous = previous

          def next(self):
              "*** YOUR CODE HERE ***"
              if self.value == 0:
                  return Fib(1, 0)
              return Fib(self.value + self.previous, self.value)

          def __repr__(self):
              return str(self.value)

          "sol2 "
          def __init__(self):
              self.value = 0
              self.next_value = 1

          def next(self):
              b = Fib()
              b.value = self.next_value
              b.next_value = b.value + self.value
              return b

          def __repr__(self):
              return str(self.value)

          "sol3"
          def __init__(self, value=0, next_value=1):
              self.value = value
              self.next_value = next_value

          def next(self):
              return Fib(self.next_value, self.value + self.next_value)

          def __repr__(self):
              return str(self.value)
    #+end_src 
    - sol1 uses ~previous~ and ~value~
    - sol2 & 3 use ~next_value~ and ~value~, easier
*** Q2: Vending Machine
    #+begin_src python :results output
      class VendingMachine:
          """A vending machine that vends some product for some price.

          >>> v = VendingMachine('candy', 10)
          >>> v.vend()
          'Machine is out of stock.'
          >>> v.deposit(15)
          'Machine is out of stock. Here is your $15.'
          >>> v.restock(2)
          'Current candy stock: 2'
          >>> v.vend()
          'You must deposit $10 more.'
          >>> v.deposit(7)
          'Current balance: $7'
          >>> v.vend()
          'You must deposit $3 more.'
          >>> v.deposit(5)
          'Current balance: $12'
          >>> v.vend()
          'Here is your candy and $2 change.'
          >>> v.deposit(10)
          'Current balance: $10'
          >>> v.vend()
          'Here is your candy.'
          >>> v.deposit(15)
          'Machine is out of stock. Here is your $15.'

          >>> w = VendingMachine('soda', 2)
          >>> w.restock(3)
          'Current soda stock: 3'
          >>> w.restock(3)
          'Current soda stock: 6'
          >>> w.deposit(2)
          'Current balance: $2'
          >>> w.vend()
          'Here is your soda.'
          """
          "*** YOUR CODE HERE ***"
          def __init__(self, name, price):
              self.name = name
              self.price = price
              self.rest = 0
              self.balance = 0

          def restock(self, x):
              self.rest += x
              return 'Current {0} stock: {1}'.format(self.name, self.rest)

          def deposit(self, x):
              if self.rest == 0:
                  return 'Machine is out of stock. Here is your ${0}.'.format(x)
              else:
                  self.balance += x
                  return 'Current balance: ${0}'.format(self.balance)

          def vend(self):
              if self.rest == 0:
                  return 'Machine is out of stock.'
              elif self.balance < self.price:
                  more = self.price - self.balance
                  return 'You must deposit ${0} more.'.format(more)
              else:
                  self.balance -= self.price
                  self.rest -= 1
                  if self.balance == 0:
                      return 'Here is your {0}.'.format(self.name)
                  else:
                      more = self.balance
                      self.balance = 0
                      return 'Here is your {0} and ${1} change.'.format(self.name, more)
    #+end_src 
    - ~'djfie' + 2~ throws ~TypeError: can only concatenate str (not "int") to str~, not like Java. -> ~'djfie{0}'.format(2)~ 
