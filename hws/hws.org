#+TAGS: OUTSTANDING(o) QUESTIONS(q)

* HW01
** Q4: If Function vs Statement
   
   #+begin_src python :results output
     def if_function(condition, true_result, false_result):
         """Return true_result if condition is a true value, and
         false_result otherwise.

         >>> if_function(True, 2, 3)
         2
         >>> if_function(False, 2, 3)
         3
         >>> if_function(3==2, 3+2, 3-2)
         1
         >>> if_function(3>2, 3+2, 3-2)
         5
         """
         if condition:
             return true_result
         else:
             return false_result


     def with_if_statement():
         """
         >>> result = with_if_statement()
         2
         >>> print(result)
         None
         """
         if c():
             return t()
         else:
             return f()

     def with_if_function():
         """
         >>> result = with_if_function()
         1
         2
         >>> print(result)
         None
         """
         return if_function(c(), t(), f())

     def c():
         "*** YOUR CODE HERE ***"
         return False

     def t():
         "*** YOUR CODE HERE ***"
         print(1)

     def f():
         "*** YOUR CODE HERE ***"
         print(2)
   #+end_src 

   1. ~with_if_statement~ prints ~2~ while ~with_if_function~ prints both ~1~ and ~2~.
** Q5: Hailstone

   #+begin_src python :results output
     def hailstone(n):
         """Print the hailstone sequence starting at n and return its
         length.

         >>> a = hailstone(10)
         10
         5
         16
         8
         4
         2
         1
         >>> a
         7
         """
         "*** YOUR CODE HERE ***"
         a = 1
         while n != 1:
             print(n)
             if n % 2 == 0:
                 n //= 2
             else:
                 n = n*3 + 1
             a += 1
         print(1)
         return a
   #+end_src 

   1. Hailstone sequence.
** Q6: Quine
   
   #+begin_src python :results output
     s = 'print("s = " + repr(s) + "; eval(s)")'; eval(s)
   #+end_src 

   #+RESULTS:
   : s = 'print("s = " + repr(s) + "; eval(s)")'; eval(s)
    
   - ~repr(object)~ vs ~str(object)~
     - ~str()~ is used for creating output for *end user* while ~repr()~ is mainly used for *debugging and development*. ~repr~ ’s goal is to be *unambiguous* and ~str~ ’s is to be *readable*. For example, if we suspect a float has a *small rounding error*, ~repr~ will show us while ~str~ may not.
     - ~repr()~ compute the *“official”* string representation of an *object* (a representation that has *all information* about the abject) and ~str()~ is used to compute the *“informal”* string representation of an *object* (a representation that is *useful for printing* the object).
     - The ~print~ statement and ~str()~ built-in function uses ~__str__~ to display the string representation of the object while the ~repr()~ built-in function uses ~__repr__~ to display the object.
       
     #+begin_src python :results output
       import datetime 
       today = datetime.datetime.now() 
       # Prints readable format for date-time object 
       print(str(today))

       # prints the official format of date-time object 
       print(repr(today))
     #+end_src 

     #+RESULTS:
     : 2019-04-22 19:36:13.823131
     : datetime.datetime(2019, 4, 22, 19, 36, 13, 823131)

   - ~eval(expression, globals=None, locals=None)~
     - ~expression~: this *string* is *parsed and evaluated* as a Python expression
     - ~globals~ (optional): a *dictionary* to specify the available *global methods and variables*
     - ~locals~ (optional): another *dictionary* to specify the available *local methods and variables* 
*** Question:                                                     :QUESTIONS:
    1. 关于quine程序的原理的理解？结合上面例子。
* HW02
** Q1: Make Adder with a Lambda

   #+begin_src python :results output
     def make_adder(n):
         """Return a function that takes an argument K and returns N + K.

         >>> add_three = make_adder(3)
         >>> add_three(1) + add_three(2)
         9
         >>> make_adder(1)(2)
         3
         """
         return lambda k: n + k

     def make_adder1(n):
         def inner(k):
             return n + k
         return inner
   #+end_src 

   1. ~lambda args: expression~.
   2. ~make_adder(1)(2)~. 

** Q3: Accumulate 

   #+begin_src python :results output
     def accumulate(combiner, base, n, term):
         """Return the result of combining the first n terms in a sequence and base.
         The terms to be combined are term(1), term(2), ..., term(n).  combiner is a
         two-argument commutative, associative function.

         >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
         15
         >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
         26
         >>> accumulate(add, 11, 0, identity) # 11
         11
         >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
         25
         >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
         72
         """
         "*** YOUR CODE HERE ***"
         result, i = base, 1
         while i <= n:
             result, i = combiner(result, term(i)), i + 1
         return result

     def accumulate2(combiner, base, n, term):
         if n == 0:
             return base
         return combiner(term(n), accumulate2(combiner, base, n-1, term))

     def accumulate3(combiner, base, n, term):
         if n == 0:
             return base
         return accumulate3(combiner, combiner(base, term(n)), n-1, term)

     def summation_using_accumulate(n, term):
         """Returns the sum of term(1) + ... + term(n). The implementation
         uses accumulate.

         >>> summation_using_accumulate(5, square)
         55
         >>> summation_using_accumulate(5, triple)
         45
         >>> from construct_check import check
         >>> check(HW_SOURCE_FILE, 'summation_using_accumulate',
         ...       ['Recursion', 'For', 'While'])
         True
         """
         "*** YOUR CODE HERE ***"
         return accumulate(add, 0, n, term)

     def product_using_accumulate(n, term):
         """An implementation of product using accumulate.

         >>> product_using_accumulate(4, square)
         576
         >>> product_using_accumulate(6, triple)
         524880
         >>> from construct_check import check
         >>> check(HW_SOURCE_FILE, 'product_using_accumulate',
         ...       ['Recursion', 'For', 'While'])
         True
         """
         "*** YOUR CODE HERE ***"
         return accumulate(mul, 1, n, term)
   #+end_src 

   1. *Loop method*: ~combiner(combiner(...combiner(term(1), base)..., term(n-1)), term(n))~.
   2. *Recursive method*:
      - ~accumulate2~: treat ~combiner(...combiner(base, term(1))..., term(n-1))~ as ~accumulate2(combiner, base, n-1, term)~ and ~return combiner(term(n), accumulate2(combiner, base, n-1, term)~.    
      - ~accumulate3~: treat ~combiner(base, term(n))~ as ~base~ and ~return accumulate3(combiner, combiner(base, term(n)), n-1, term)~.    
   3. ~return accumulate(add, 0, n, term)~ and ~return accumulate(mul, 1, n, term)~.
** Q4: Make Repeater

   #+begin_src python :results output
     def compose1(f, g):
         """Return a function h, such that h(x) = f(g(x))."""
         def h(x):
             return f(g(x))
         return h

     def make_repeater(f, n):
         """Return the function that computes the nth application of f.

         >>> add_three = make_repeater(increment, 3)
         >>> add_three(5)
         8
         >>> make_repeater(triple, 5)(1) # 3 * 3 * 3 * 3 * 3 * 1
         243
         >>> make_repeater(square, 2)(5) # square(square(5))
         625
         >>> make_repeater(square, 4)(5) # square(square(square(square(5))))
         152587890625
         >>> make_repeater(square, 0)(5)
         5
         """
         "*** YOUR CODE HERE ***"
         def g(x, t = f, m = n):
             if m == 0:
                 return x
             else:
                 m -= 1
                 return t(g(x, t, m))
         return g
     """ solutions """
     def make_repeater2(f, n):
         g = identity
         while n > 0:
             g = compose1(f, g)
             n = n - 1
         return g

     def make_repeater3(f, n):
         def h(x):
             k = 0
             while k < n:
                 x, k = f(x), k + 1
             return x
         return h

     def make_repeater4(f, n):
         if n == 0:
             return lambda x: x
         return lambda x: f(make_repeater4(f, n - 1)(x))

     def make_repeater5(f, n):
         if n == 0:
             return lambda x: x
         return compose1(f, make_repeater5(f, n - 1))

     def make_repeater6(f, n):
         return accumulate(compose1, lambda x: x, n, lambda k: f)
   #+end_src 

   - *Iterative method*: ~f(...f(f(x))...)~
     1. Non ~x~ but ~compose1~ in ~make_repeater2~: Treat ~f~ as ~f(g)~ and def ~g = identity~, use ~compose1(f, g)~ to get ~f(g)~, each iteration *change* ~g = f(g)~, finally return ~g = f(...(f(g))...)~.
     2. Non ~compose1~ but ~x~ in ~make_repeater3~: def ~h~ and return ~h~, in ~h~ *directly* return ~f(...f(f)...)~.
   - *Recursive method*
     1. Non ~compose1~ but ~x~ in ~make_repeater4~: Treat ~f(...f(f(x))...)~ as ~f(x)~ and ~x = ...f(f(x))... = make_repeater4(f, n - 1)(x)~, return ~f(x) = f(make_repeater4(f, n - 1)(x))~.
     2. Non ~x~ but ~compose1~ in ~make_repeater5~: Treat ~f(...f(f)...)~ as ~f(g)~ and ~g = ...f(f)... = make_repeater5(f, n - 1)~, return ~f(g) = compose1(f, make_repeater5(f, n - 1))~.
     3. *One line* return with ~compose1~ and ~accumulate~ in ~make_repeater6~: ~combiner~ take in *two values* and return a new *value*, while ~compose1~ take in *two funcs* and return a new *func*, ~combiner(combiner(...combiner(base, term(1))..., term(n-1)), term(n))~ = ~compose1(compose1(...compose1(x, k)..., k), k)~ = ~accumulate(compose1, lambda x: x, n, lambda k: f)~.
*** Question:
    1. 关于Loop方法，这两种思维上有何不同？是否用 ~compose1~ 加深了一层抽象？比较而言各适用于什么场景？
    2. 关于Recursive方法，第3种中所有 ~term(i)~ 为什么都等于 ~f~ ？在 ~accumulate~ 中 ~combiner~ 中的操作数可以互换，这里由于 ~compose1~ 的定义应该考虑 ~(lambda k: f, lambda x: x)~ 才对，为何实际两者仍然可以互换？这3种方法思维上有何根本不同？各适用于什么场景？
    3. 以上分析能否改进？（补充或精简统一）
** Q5: Church numerals
   
   #+begin_src python :results output
     def zero(f):
         return lambda x: x

     def successor(n):
         return lambda f: lambda x: f(n(f)(x))

     def one(f):
         """Church numeral 1: same as successor(zero)"""
         "*** YOUR CODE HERE ***"
         return lambda x: f(x)

     def two(f):
         """Church numeral 2: same as successor(successor(zero))"""
         "*** YOUR CODE HERE ***"
         return lambda x: f(f(x))

     three = successor(two)

     def church_to_int(n):
         """Convert the Church numeral n to a Python integer.

         >>> church_to_int(zero)
         0
         >>> church_to_int(one)
         1
         >>> church_to_int(two)
         2
         >>> church_to_int(three)
         3
         """
         "*** YOUR CODE HERE ***"
         return n(lambda x: x + 1)(0)

     def add_church(m, n):
         """Return the Church numeral for m + n, for Church numerals m and n.

         >>> church_to_int(add_church(two, three))
         5
         """
         "*** YOUR CODE HERE ***"
         return lambda f: lambda x: m(f)(n(f)(x))

     def mul_church(m, n):
         """Return the Church numeral for m * n, for Church numerals m and n.

         >>> four = successor(three)
         >>> church_to_int(mul_church(two, three))
         6
         >>> church_to_int(mul_church(three, four))
         12
         """
         "*** YOUR CODE HERE ***"
         return lambda f: m(n(f))

     def pow_church(m, n):
         """Return the Church numeral m ** n, for Church numerals m and n.

         >>> church_to_int(pow_church(two, three))
         8
         >>> church_to_int(pow_church(three, two))
         9
         """
         "*** YOUR CODE HERE ***"
         return n(m)
   #+end_src 

   1. f
   2. 

*** Question:                                                     :QUESTIONS:
    1. 怎么理解这种思路？这种问题与这种问题的解法的特点？与high order func联系起来，是否能从多级order或者说多层抽象来思考？
jdifjeiji
* HW03 
** Q2: Ping-pong
   
   #+begin_src python :results output
     def pingpong(n):
         """Return the nth element of the ping-pong sequence.

         >>> pingpong(7)
         7
         >>> pingpong(8)
         6
         >>> pingpong(15)
         1
         >>> pingpong(21)
         -1
         >>> pingpong(22)
         0
         >>> pingpong(30)
         6
         >>> pingpong(68)
         2
         >>> pingpong(69)
         1
         >>> pingpong(70)
         0
         >>> pingpong(71)
         1
         >>> pingpong(72)
         0
         >>> pingpong(100)
         2
         >>> from construct_check import check
         >>> check(HW_SOURCE_FILE, 'pingpong', ['Assign', 'AugAssign'])
         True
         """
         "*** YOUR CODE HERE ***"
         def is_change(n):
             return (has_seven(n) or n % 7 == 0)

         def is_up(n):
             if n == 1:
                 return True
             elif is_change(n):
                 return not is_up(n-1)
             else:
                 return is_up(n-1)

         if n == 1:
             return 1
         elif is_up(n-1):
             return pingpong(n-1) + 1
         else:
             return pingpong(n-1) - 1
     """ solutioins """
     def pingping_iteration(n):
         result, i = 1, 1
         is_up = True
         while i < n:
             if has_seven(i) or i % 7 == 0:
                 is_up = not is_up
             if is_up:
                 result += 1
             else:
                 result -= 1
                 i += 1
         return result

     def pingpong2(n):
         def helper(result, i, step):
             if i == n:
                 return result
             elif i % 7 == 0 or has_seven(i):
                 return helper(result - step, i + 1, -step)
             else:
                 return helper(result + step, i + 1, step)
         return helper(1, 1, 1)

     def pingpong3(n):
         def pingpong_next(x, i, step):
             if i == n:
                 return x
             return pingpong_next(x + step, i + 1, next_dir(step, i+1))

         def next_dir(step, i):
             if i % 7 == 0 or has_seven(i):
                 return -step
             return step

         return pingpong_next(1, 1, 1)

     def pingpong4(n):
         def direction(n):
             if n < 7:
                 return 1
             if (n-1) % 7 == 0 or has_seven(n-1):
                 return -1 * direction(n-1)
             return direction(n-1)

         if n <= 7:
             return n
         return direction(n) + pingpong(n-1)

   #+end_src 
   

   - Both *recursive and iterative* method can start from *1 to n* or *n to 1*
     | start to end | recursive func                   | return value  | base        | example                  |
     | 1 to n       | new defined helper func ~helper~ | ~helper(i+1)~ | ~helper(n)~ | ~pingpong2~, ~pingpong3~ |
     | n to 1       | itself ~func~                    | ~func(n-1)~   | ~func(1)~   | ~pingpong~, ~pingpong4~  |
*** Question:
    1. 关于新定义 ~helper~ 并利用它从1开始递归到n本质上不就是iterative吗？从1到n和从n到1本质上有什么区别？ 
** Q3: Filtered Accumulate

   #+begin_src python :results output
     def accumulate(combiner, base, n, term):
         """Return the result of combining the first n terms in a sequence and base.
         The terms to be combined are term(1), term(2), ..., term(n).  combiner is a
         two-argument, associative function.

         >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
         15
         >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
         26
         >>> accumulate(add, 11, 0, identity) # 11
         11
         >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
         25
         >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
         72
         """
         total, k = base, 1
         while k <= n:
             total, k = combiner(total, term(k)), k + 1
         return total

     def filtered_accumulate(combiner, base, pred, n, term):
         """Return the result of combining the terms in a sequence of N terms
         that satisfy the predicate pred. combiner is a two-argument function.
         If v1, v2, ..., vk are the values in term(1), term(2), ..., term(N)
         that satisfy pred, then the result is
              base combiner v1 combiner v2 ... combiner vk
         (treating combiner as if it were a binary operator, like +). The
         implementation uses accumulate.

         >>> filtered_accumulate(add, 0, lambda x: True, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
         15
         >>> filtered_accumulate(add, 11, lambda x: False, 5, identity) # 11
         11
         >>> filtered_accumulate(add, 0, odd, 5, identity)   # 0 + 1 + 3 + 5
         9
         >>> filtered_accumulate(mul, 1, greater_than_5, 5, square)  # 1 * 9 * 16 * 25
         3600
         >>> # Do not use while/for loops or recursion
         >>> from construct_check import check
         >>> check(HW_SOURCE_FILE, 'filtered_accumulate',
         ...       ['While', 'For', 'Recursion'])
         True
         """
         def combine_if(x, y):
             "*** YOUR CODE HERE ***"
             if pred(y):
                 return combiner(x, y)
             else:
                 return x

         return accumulate(combine_if, base, n, term)

     def odd(x):
         return x % 2 == 1

     def greater_than_5(x):
         return x > 5
   #+end_src 

   - ~combine_if(total, term(k)~ in ~accumulate(combine_if, base, n, term)~    
