#+TAGS: OUTSTANDING(o) QUESTIONS(q)

* Chapter 1: Building Abstractions with Functions
** Funcs
*** Expressions
**** Types of expressions
     An expression describes a computation and evaluates to a value
***** Primitive expressions
      ~2 + 1~
***** Call expressions
      ~max(2,3)~
**** Call Expressions in Python
     All expressions can use func call notation
     ~max(2,3)~
**** Anatomy of a Call Expression
     Evaluation procedure for call expressions:
     ~add(2, 3)~ 
     Operators and operands are also expressions, so they evaluate to values.
***** Evaluate the operator and then the operand subexpressions

     | operator | add |
     | operand1 |   2 |
     | operand2 |   3 |

***** Apply the func that is the value of the operator subexpression to the args that are the values of the operand subexpression

     | func  | value of add |
     | arg1 | value of 2   |
     | arg2 | value of 3   |

**** Evaluating Nested Expressions
    ~mul(add(4,mul(4, 6)), add(3, 5))~ 

    #+BEGIN_SRC dot :file ./func-1.png :exports results
      digraph func1 {
            a1 [label="mul(add(4,mul(4, 6)), add(3, 5))"];
            a2 [label="add(4,mul(4,6))"];
            a3 [label="add(3,5)"];
            a5 [label="mul(4,6)"];
            4 [shape=box];
            6 [shape=box];
            3 [shape=box];
            5 [shape=box];
            a1->a2->4;
            a2->a5->4;
            a5->6;
            a1->a3->3;
            a3->5;
      }     
    #+END_SRC

    #+RESULTS:
    [[file:./func-1.png]]

*** Funcs, Values, Objects, Interpreters, and Data
**** Objects

     #+BEGIN_SRC python :session Objects :results output
       from urllib.request import urlopen
       shakes = urlopen('http://composingprograms.com/shakespeare.txt')
       text = shakes.read().split()
     #+END_SRC 

     #+BEGIN_SRC python :session Objects :results output
       print(len(text),'\n',text[:25],'\n', text.count(b'the'), '\n', text.count(b','))
     #+END_SRC 

     #+RESULTS:
     : 980637 
     :  [b'A', b"MIDSUMMER-NIGHT'S", b'DREAM', b'Now', b',', b'fair', b'Hippolyta', b',', b'our', b'nuptial', b'hour', b'Draws', b'on', b'apace', b':', b'four', b'happy', b'days', b'bring', b'in', b'Another', b'moon', b';', b'but', b'O'] 
     :  23272 
     :  81827

**** Sets 

     #+BEGIN_SRC python :session Objects :results output
       words = set(text)
       print(len(words),'\n',max(words))
     #+END_SRC 

     #+RESULTS:
     : 33505 
     :  b'zwaggered'

**** Reversals 

     #+BEGIN_SRC python :session Objects :results output
       print('draw'[::-1])
       print({w for w in words if w == w[::-1] and len(w)>4})
       print({w for w in words if w[::-1] in words and len(w) == 4})
       print({w for w in words if w[::-1] in words and len(w) > 6})
     #+END_SRC 

     #+RESULTS:
     : ward
     : {b'rever', b'madam', b'level', b'minim', b'redder', b'refer'}
     : {b'noon', b'snip', b'tops', b'smug', b'garb', b'maws', b'rail', b'flow', b'trap', b'ward', b'doom', b'rood', b'drab', b'dial', b'sees', b'stab', b'leer', b'keel', b'lees', b'wort', b'mood', b'spin', b'stop', b'leek', b'meed', b'loop', b'star', b'draw', b'teem', b'liar', b'poop', b'trow', b'gums', b'spot', b'gnat', b'room', b'elle', b'door', b'hoop', b'tang', b'bard', b'swam', b'live', b'pooh', b'deed', b'laid', b'rats', b'evil', b'seel', b'nips', b'brag', b'ecce', b'pool', b'spit', b'part', b'tips', b'pots', b'moor', b'meet', b'esse', b'peep', b'reel', b'deem', b'pins', b'wolf', b'deer', b'port', b'trop', b'bats', b'reed'}
     : set()
     
** Names
*** Env Diagrams
**** Env Diagrams
     Env diagrams visualize the interpreter’s process.
***** Code
      Statements and expressions

      #+BEGIN_SRC python 
        from math import pi
        tau = 2 * pi
        return pi, tau
      #+END_SRC 

      #+RESULTS:
      | 3.141592653589793 | 6.283185307179586 |

***** Frames
      Each name is bound to a value. Within a frame, a name cannot be repeated

     | Global frame |        |
     |--------------+--------|
     | name         |  value |
     | pi           | 3.1416 |
     | tau          | 6.2832 |

**** Assignment Statements
***** Execution rule for assignment statements:
      - Evaluate all expressions to the right of = from left to right.
      - Bind all names to the left of = to those resulting values in the current frame.
       
      #+BEGIN_SRC python :results output
        a = 1
        b = 2
        b, a = a + b, b
        print(a,b)
      #+END_SRC

      #+RESULTS:
      : 2 3

*** Defining Funcs
**** Defining Funcs
     Assignment is a simple means of abstraction: binds names to values
     Func def is a more powerful means of abstraction: binds names to expressions
    
     #+BEGIN_SRC python
       def <name>(<formal parameters>): 
           return <return expression>
     #+END_SRC

***** Execution procedure for def statements:
      1. Create a func with signature ~<name>(<formal parameters>)~, func signature indicates how many args a func takes, it has all the
 information needed to create a local frame.
      2. Set the body of that func to be everything indented after the first line, func body defines the computation performed when the func is applied
      3. Bind ~<name>~ to that func in the current frame
**** Calling User-Defined Funcs
***** Procedure for calling/applying user-defined funcs
      1. Add a local frame, forming a new env
      2. Bind the func's formal parameters to its args in that frame
      3. Execute the body of the func in that new env
**** Looking Up Names In Env
     Every expression is evaluated in the context of an env. So far, the current env is either: 
     - The global frame alone, or
     - A local frame, followed by the global frame. 
***** Most important two things:
      1. An env is a sequence of frames. 
      2. A name evaluates to the value bound to that name in the earliest frame of the current env in which that name is found.
** Control
*** Print and None
**** None Indicates that Nothing is Returned
    - The special value ~None~ represents nothing in Python
    - A func that does not explicitly return a value will return ~None~
    - Careful: ~None~ is not displayed by the interpreter as the value of an expression
     
     #+begin_src python 
       def does_not_return_square(a):
           a*a
       x = does_not_return_square(4) + 3 
       return x
     #+end_src

**** Pure Funcs & Non-Pure Funcs
***** Pure Funcs
      just return *values*: ~abs()~   
     
      #+begin_src python 
        return abs(-2)
      #+end_src

      #+RESULTS:
      : 2

***** Non-Pure Funcs     
      return *values(None)* and have *side effects*: ~print()~

      #+begin_src python :results output
        a = print(2)
        print(a)
      #+end_src

      #+RESULTS:
      : 2
      : None

**** Nested Expressions with Print
    
     #+begin_src python :results output
       a = print(print(1), print(2))
       print(a)
     #+end_src

     #+RESULTS:
     : 1
     : 2
     : None None
     : None
    
*** Multiple Envs
**** Life Cycle of a User-Defined Func 
***** Def statement:

      #+begin_src python
        def square(x):
            return mul(x, x)
      #+end_src
    
      - A new func is created!
      - Name bound to that func in the current frame 
***** Call expression: 
      ~square(2+2)~ 
      - Operator & operands evaluated
      - Func (value of operator) called on args (values of operands):
***** Calling/Applying: 
      - A new frame is created!
      - Body is executed in that new env
**** Multiple Envs in One Diagram!
    
     #+BEGIN_SRC python :results output
       from operator import mul
       def square(x):
           return mul(x, x);
       print(square(square(3)))
     #+END_SRC 

     #+RESULTS:
     : 81

     An env is a sequence of frames.
     - The global frame alone
     - A local, then the global frame
     *One env per frame here* 
***** ENV1 

      | Frames | Global      |
      | funcs  | mul, square |

***** ENV2

      | Frames       | f2: square [parent=Global |
      | x            |                         3 |
      | return value |                         9 |

***** ENV3

      | Frames       | f3: square [parent=Global |
      | x            |                         9 |
      | return value |                        81 |

**** Names Have No Meaning Without Envs
     - Every expression is evaluated in the context of an env.
     - A name evaluates to the value bound to that name in the earliest frame of the current env in which that name is found.
**** Names Have Different Meanings in Different Envs
    
     #+BEGIN_SRC python :results output
       from operator import mul
       def square(square):
           return mul(square, square)
       print(square(4))
     #+END_SRC 

     #+RESULTS:
     : 16

     *A call expression and the body of the func being called are evaluated in different envs*

     | call of square(4) | ENV1:Global                |
     | body of square(4) | ENV2:f1 followed by Global |

*** Miscellaneous Python Features
**** Operators
***** Addition 

      #+BEGIN_SRC python :results output
        print(2+3*4+5,'\n',(2+3)*(4+5))
      #+END_SRC 

      #+RESULTS:
      : 19 
      :  45

***** Division

      #+BEGIN_SRC python :results output
        print(618 / 10, 618 // 10, 618 % 10)
        from operator import truediv, floordiv, mod
        print(truediv(618, 10), floordiv(618, 10), mod(618, 10))
      #+END_SRC 

      #+RESULTS:
      : 61.8 61 8
      : 61.8 61 8

**** Multiple Return Values 

     #+BEGIN_SRC python :results output
       def divide_exact(n, d):
           return n // d, n % d
       quotient, remainder = divide_exact(618, 10)
       print(quotient, remainder)
     #+END_SRC 

     #+RESULTS:
     : 61 8

**** Docstrings, doctests, & default args
     use *python3 -m doctest test.py* to doctest. 

     #+BEGIN_SRC python :results output
       def divide_exact(n, d=10):
           """Return the quotient and remainder of dividing N by D.

           >>> quotient, remainder = divide_exact(618, 10)
           >>> quotient
           61
           >>> remainder
           8
           """
           return floordiv(n, d), mod(n, d)
     #+END_SRC 

**** Conditional Statements
***** Statements
      A *statement* is executed by the *interpreter* to perform an action

***** Compound statements 

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-05 16:46:10
      [[file:Control/screenshot_2019-03-05_16-46-10.png]]
 
      The first header determins a *statement's type*: ~def~ ~if~ ~while~...
 
***** Conditional Statements

      #+begin_src python :results output
        def absolute_value(x):
            if x < 0:
                return -x
            elif x == 0:
                return0
            else:
                return x
      #+end_src 
      
      1 statement, 3 clauses, 3 headers, 3 suites.

***** Boolean Contexts
      In python

      | False | False, 0, '', None, [], ... |
      | True  | Not false                   |

**** Iteration
***** While Statements
      
      #+begin_src python :results output
        i,total = 0, 0
        while i < 3:
            i = i + 1
            total = total + 1
      #+end_src 

***** Example: The Fibonacci Sequence
      
      #+begin_src python :results output
        def fib(n):
            """Compute the nth Fibonacci number"""
            pred, curr = 0, 1 #--> pred, curr = 1, 0
            k = 1             #--> k = 0
            while k < n:
                pred, curr = curr, pred + curr
                k = k + 1
            return curr
      #+end_src 
      
** 1.6 Higher-Order Funcs
   Funcs that *manipulate funcs* are called *higher-order funcs*
*** 1.6.1 Funcs as Args
   
    #+begin_src python :results output
      def sum_naturals(n):
              total, k = 0, 1
              while k <= n:
                  total, k = total + k, k + 1
              return total

      def sum_cubes(n):
              total, k = 0, 1
              while k <= n:
                  total, k = total + k*k*k, k + 1
              return total

      def pi_sum(n):
              total, k = 0, 1
              while k <= n:
                  total, k = total + 8 / ((4*k-3) * (4*k-1)), k + 1
              return total

      def summation(n, term):
              total, k = 0, 1
              while k <= n:
                  total, k = total + term(k), k + 1
              return total

      def identity(x):
              return x

      def sum_naturals(n):
              return summation(n, identity)

      def cube(x):
          return x*x*x

      def sum_cubes(n):
          return summation(n, cube)

      def pi_term(x):
              return 8 / ((4*x-3) * (4*x-1))

      def pi_sum(n):
              return summation(n, pi_term)
    #+end_src 

*** 1.6.2 Funcs as General Methods
**** A more powerful kind of abstraction in higher-order funcs
     Some funcs express *general methods of computation*, *independent of the particular funcs* they call.

     #+begin_src python :results output
       def improve(update, close, guess=1):
               while not close(guess):
                   guess = update(guess)
               return guess

       def golden_update(guess):
               return 1/guess + 1

       def square_close_to_successor(guess):
               return approx_eq(guess * guess, guess + 1)

       def approx_eq(x, y, tolerance=1e-15):
               return abs(x - y) < tolerance

       phi = improve(golden_update,square_close_to_successor)
     #+end_src 

     - This ~improve~ func is a *general expression* of repetitive refinement.It *doesn't specify* what problem is being solved: those *details* are left to the ~update~ and ~close~ funcs passed in as args.
     - When a user-defined func is *applied* to some args, the formal parameters are bound to the values of those arguments (which *may be funcs*) in a *new local frame*.
     
     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-11 07:28:36
     [[file:1.6%20Higher-Order%20Funcs/screenshot_2019-03-11_07-28-36.png]]

**** Two related big ideas in computer science
     - *Naming and funcs* allow us to *abstract away* a vast amount of *complexity*.
     - Only an *extremely general evaluation procedure* for the Python language can make *small components* composed into *complex processes*.
   
**** A test to check its correctness. 

     #+begin_src python :results output
       from math import sqrt
       phi = 1/2 + sqrt(5)/2
       def improve_test():
               approx_phi = improve(golden_update, square_close_to_successor)
               assert approx_eq(phi, approx_phi), 'phi differs from its approximation'

       improve_test()
     #+end_src 

*** 1.6.3 Defining Funcs III: Nested Defs
**** Problems of passing funcs as args
     Pass functions as arguments significantly *enhances the expressive power* of python.
*****  Two problems 
      - *Global frame* becomes *cluttered with names* of small functions, which must all be *unique*.
      - We are *constrained by particular function signatures*.(the ~update~ argument to ~improve~ must take exactly *one argument*.)
**** Nested func def address problems above
***** Example: square root of a number
   
      #+begin_src python :results output
        def average(x, y):
            return (x + y)/2

        def improve(update, close, guess=1):
            while not close(guess):
                guess = update(guess)
            return guess

        def approx_eq(x, y, tolerance=1e-3):
            return abs(x - y) < tolerance

        def sqrt(a):
            def sqrt_update(x):
                return average(x, a/x)
            def sqrt_close(x):
                return approx_eq(x * x, a)
            return improve(sqrt_update, sqrt_close)

        result = sqrt(256)
      #+end_src 

****** Env review
******* Most important two things:
        1. An env is a sequence of frames. 
        2. A name evaluates to the value bound to that name in the earliest frame of the current env in which that name is found.
******* Life Cycle of a User-Defined Func 
******** Def statement:
         - Name bound to that func in the current frame 
******** Calling/Applying: 
         - A new frame is created!
         - Body is executed in that new env
****** Env analysis

       #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-11 13:03:05
       [[file:1.6%20Higher-Order%20Funcs/screenshot_2019-03-11_13-03-05.png]]

       | Env                     | Frame(created when calling func)           | Func evaluated within frame               | Arg evaluted within frame                            |
       | Env1                    | Global                                     | ~average~, ~improve~, ~approx_eq~, ~sqrt~ | None                                                 |
       | Env2 extended from Env1 | f1: ~sqrt~ [parent=Global                  | ~sqrt_update~, ~sqrt_close~               | a=256                                                |
       | Env3 extended from Env1 | f2: ~improve~ [parent=Global               | None                                      | update= ~sqrt_update~, close= ~sqrt_close~ , guess=1 |
       | Env4 extended from Env2 | f3: ~sqrt_close~ [parent=f1 [parent=Global | None                                      | x=1, a=256(from parent f1)                           |
       | Env5 extended from Env1 | f4: ~approx_eq~ [parent=Global             | None                                      | x=1, y=256, tolerance=0.001                          |
     
       #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-11 13:05:31
       [[file:1.6%20Higher-Order%20Funcs/screenshot_2019-03-11_13-05-31.png]]  
 
       | Env                     | Frame(created when calling func)            | Func evaluated within frame               | Arg evaluted within frame                            |
       | Env1                    | Global                                      | ~average~, ~improve~, ~approx_eq~, ~sqrt~ | None                                                 |
       | Env2 extended from Env1 | f1: ~sqrt~ [parent=Global                   | ~sqrt_update~, ~sqrt_close~               | a=256                                                |
       | Env3 extended from Env1 | f2: ~improve~ [parent=Global                | None                                      | update= ~sqrt_update~, close= ~sqrt_close~ , guess=1 |
       | Env6 extended from Env2 | f5: ~sqrt_update~ [parent=f1 [parent=Global | None                                      | x=1, a=256(from parent f1)                           |
       | Env7 extended from Env1 | f6: ~average~ [parent=Global                | None                                      | x=1, y=256                                           |

****** Lexical scope
       The *inner funcs* have access to the *names* in the env where they are *defined* (*not* where they are *called*).
******* Two extensions to our env model to enable lexical scoping
        - Each user-defined func has a *parent env*: the environment in which it was *defined*.
        - When a user-defined func is *called*, its *local frame extends its parent env*.
******* Two key advantages of lexical scoping in Python
        - The *names of a local func* do *not interfere* with *names external* to the function in which it is *defined*, because the local function name will be bound in the *current local env* in which it was *defined*, rather than the *global environment*.
        - A local func can *access the env* of the *enclosing func*, because the *body of the local func* is evaluated in an env that *extends the evaluation environment* in which it was *defined*.

*** 1.6.4 Funcs as Returned Values
    Funcs as returned values can achieve more *expressive power*.
**** Example: function *composition* h(x) = f(g(x))

    #+begin_src python :results output
      def square(x):
          return x*x

      def successor(x):
          return x + 1

      def composel(f, g):
          def h(x):
              return f(g(x))
          return h

      def f(x):
          """Never called"""
          return -x

      square_successor = composel(square, successor)
      result = square_successor(12)
    #+end_src 

***** Env analysis

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-12 09:30:50
      [[file:1.6%20Higher-Order%20Funcs/screenshot_2019-03-12_09-30-50.png]]
 
      | Env                     | Frame(created when calling func)  | Func evaluated within frame                                | Arg evaluted within frame   |
      | Env1                    | Global                            | ~square~, ~successor~, ~compose1~, ~f~, ~square_successor~ | None                        |
      | Env2 extended from Env1 | f1: ~compose1~ [parent=Global     | ~h~                                                        | f= ~square~, g= ~successor~ |
      | Env3 extended from Env2 | f2: ~h~ [parent=f1 [parent=Global | None                                                       | x=12                        |
      | Env4 extended from Env1 | f3: ~successor~ [parent=Global    | None                                                       | x=12                        |
      | Env5 extended from Env1 | f4: ~square~ [parent=Global       | None                                                       | x=13                        |
     
      - ~f~ and ~g~ are ~resolved correctly~, even in the presence of *conflicting* names(~f~ defined in Global frame).
      - An important feature of *lexically scoped* programming languages: *locally defined* functions *maintain* their *parent environment* when they are *returned* (when return ~f(g(x))~, ~f~ and ~g~ are found from parent frame f1)
***** Question:                                                   :QUESTIONS:
      1. 怎么结合env分析比较好的描述程序执行过程？包括环境之间的跳转，返回等。用哪种方式，dot画环境跳转、参数传递、返回值和拓展关系图可行吗？

*** 1.6.5 Example: Newton's Method
    This extended example shows how function *return values and local definitions* can *work together* to express general ideas concisely.
**** Square root

     #+begin_src python :results output
       def improve(update, close, guess=1):
           while not close(guess):
               guess = update(guess)
           return guess

       def approx_eq(x, y, tolerance=1e-3):
           return abs(x - y) < tolerance

       def newton_update(f, df):
           def update(x):
               return x - f(x) / df(x)
           return update

       def find_zero(f, df):
           def near_zero(x):
               return approx_eq(f(x), 0)
           return improve(newton_update(f, df), near_zero)

       def square_root_newton(a):
           def f(x):
               return x * x - a
           def df(x):
               return 2 * x
           return find_zero(f, df)

       square_root_newton(64)
     #+end_src 

**** Nth root

     #+begin_src python :results output
       def improve(update, close, guess=1):
           while not close(guess):
               guess = update(guess)
           return guess

       def approx_eq(x, y, tolerance=1e-3):
           return abs(x - y) < tolerance

       def newton_update(f, df):
           def update(x):
               return x - f(x) / df(x)
           return update

       def find_zero(f, df):
           def near_zero(x):
               return approx_eq(f(x), 0)
           return improve(newton_update(f, df), near_zero)

       def power(x, n):
           """Return x*x*x*...*x for x repeated n times."""
           product, k = 1, 0
           while k < n:
               product, k = product * x, k + 1
           return product

       def nth_root_of_a(n, a):
           def f(x):
               return power(x, n) - a
           def df(x):
               return n * power(x, n-1)
           return find_zero(f, df)

       nth_root_of_a(3, 64)
     #+end_src 

**** Question:                                                    :QUESTIONS:
     1. 仍然是怎么结合env分析清晰的整理程序执行过程？特别是在参数传递和返回值环节。
*** 1.6.6 Currying
    Use *higher-order functions* to convert *a function* that takes *multiple arguments* into *a chain of functions* that each take *a single argument*.
**** Example 1: manual currying

     #+begin_src python :results output
       def curried_pow(x):
           def h(y):
               return pow(x, y)
           return h


       def map_to_range(start, end, f):
           while start < end:
               print(f(start))
               start = start + 1


       map_to_range(0, 10, curried_pow(2))
     #+end_src 

     - ~curried_pow(x)(y)~ = ~pow(x, y)~
**** Example 2: automate currying

     #+begin_src python :results output
       def curry2(f):
           """Return a curried version of the given two-argument function."""
           def g(x):
               def h(y):
                   return f(x, y)
               return h
           return g


       def uncurry2(g):
           """Return a two-argument version of the given curried function."""
           def f(x, y):
               return g(x)(y)
           return f


       def map_to_range(start, end, f):
           while start < end:
               print(f(start))
               start = start + 1


       pow_curried = curry2(pow)
       map_to_range(0, 10, pow_curried(2))
       uncurry2(pow_curried)(2, 5)
     #+end_src 

     - ~curry2(f)(x)(y)~ = ~f(x, y)~
     - ~uncurry2(curry2(f))~ = ~f~ 
**** Question:                                                    :QUESTIONS:
     1. 什么情况下需要curry？为何不直接最外用多个形参？结合嵌套函数的参数传递方式理解curry的传参方式？
     2. 结合env分析？
*** 1.6.7 Lambda Expressions
    A lambda expression evaluates to a function that has a single return expression as its body. Assignment and control statements are not allowed.
    - ~lambda x: f(g(x))~: A *function* that takes ~x~ and *returns* ~f(g(x))~.
    - The *result* of a *lambda expression* is called a *lambda function*: ~<function <lambda> at 0xf3f490>~.
**** Example 1: compose with ~lambda~ expressions

     #+begin_src python :results output
       def compose1(f, g):
           return lambda x: f(g(x))

       f = compose1(lambda x: x * x, lambda y: y + 1)

       result = f(12)
     #+end_src 

*****  Env analysis
 
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-12 16:45:59
      [[file:1.6%20Higher-Order%20Funcs/screenshot_2019-03-12_16-45-59.png]]
 
**** Example 2: *compound* ~lambda~ expressions
    
     #+begin_src python :results output
       compose1 = lambda f,g: lambda x: f(g(x))
     #+end_src 

**** Question:                                                    :QUESTIONS:
     1. Example 1中结合env分析过程？
     2. Example 2的理解？ 

*** 1.6.8 Abstractions and First-Class Funcs
    - *Higher-order funcs* can *represent abstractions explicitly as elements* so they can be handled like other *computational elements*.
    - *Elements* with the *fewest restrictions* are said to have *first-class status*.Some of the "rights and privileges" of first-class elements are:
      1. They may be *bound to names*.
      2. They may be *passed as arguments to functions*.
      3. They may be *returned as the results of functions*.
      4. They may be *included in data structures*.
    - Python awards *functions full first-class status*.
*** 1.6.9 Func Decorators
    Python provides *special syntax* to apply *higher-order functions* as *part of executing a def statement*, called a *decorator*.
**** Example 1: trace

     #+begin_src python :results output
       def trace(fn):
           def wrapped(x):
               print('-> ', fn, '(', x, ')')
               return fn(x)
           return wrapped

       @trace  # or triple = trace(triple)
       def triple(x):
           return 3 * x

       triple(12)
     #+end_src 
    
     - A higher-order function ~trace~ returns a function that *precedes a call to its argument* with a print statement that *outputs the argument*.
     - With ~@trace~, name ~triple~ is bound to the ~returned function value~ of *calling ~trace~ on the newly defined ~triple~ function*: ~trace(triple(12))~.
**** Extra for experts
     The decorator symbol @ may also be followed by a call expression. The expression following @ is evaluated first (just as the name trace was evaluated above), the def statement second, and finally the result of evaluating the decorator expression is applied to the newly defined function, and the result is bound to the name in the def statement.
**** Question:                                                    :QUESTIONS:
     1. Extra for experts的理解？decorator用在什么地方？用内存去追踪程序吗？
** 1.7 Recursive Funcs
   A function is called *recursive* if the *body of the function calls the function itself*, either *directly or indirectly*. 

   #+begin_src python :results output
     def sum_digits(n):
         """Return the sum of the digits of positive integer n."""
         if n < 10:
             return n
         else:
             all_but_last, last = n // 10, n % 10
             return sum_digits(all_but_last) + last
   #+end_src 
   
   Two steps:
   - Summing all but the last digit: ~sum_digits(all_but_last)~.
   - Adding the last digit: ~sum_digits(all_but_last) + last~.
    
   Env analysis:
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-18 14:04:32
   [[file:Recursion/screenshot_2019-03-18_14-04-32.png]]

*** 1.7.1 The Anatomy of Recursive Functions
    *Base cases* + *recursive calls*: to express computation by *simplifying problems incrementally*.
**** Example: *Recursion* vs *Iteration* 

     #+begin_src python :results output
       def fact_iter(n):
           total, k = 1, 1
           while k <= n:
               total, k = total * k, k + 1
           return total

       def fact(n):
           if n == 1:
               return 1
           else:
               return n * fact(n-1)
     #+end_src 
     
***** Env analysis(only recursion)

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-18 21:22:51
      [[file:Recursion/screenshot_2019-03-18_21-22-51.png]]
      
***** Differences
      *Recursive* functions leverage the *rules of evaluating call expressions* to *bind names to values*, often *avoiding the nuisance* of *correctly assigning local names* during *iteration*. 
****** Computation cases
       - Recursion
       *final to base*: *complicate to simple*.
       - Iteration
       *final to base or base to final*: *identical*.
****** Name and frame numbers:
       - Recursion
       *less names(usually one)* but *more frames*: bind *different values* to *less names* in *different frames* to *track to characterize computation state* and return values from *all frames one by one(base to final)*.
       - Iteration
       *more names* but *less frames(usually one)*: *explicitly track some names* to *characterize computation state* and *return other names* once in *less frames*.
****** Correctness varification:
       - Recursion
       *trust simpler cases* and *only check final*: treat *recursive calls(simpler cases)* as *functional abstraction*, a form of proof by *induction*.
       - Iteration
****** Question:                                                  :QUESTIONS:
       1. 怎么检查iteration的正确?检查base开头和final结尾并trust中间过程？
*** 1.7.2 Mutual Recursion
    When a recursive procedure is *divided among two functions* that *call each other*, the functions are said to be *mutually recursive*. 
**** Example: even or odd for non-negative integers
     - a number is *even* if it is *one more than* an *odd* number
     - a number is odd if it is *one more than* an *even* number
     - 0 is even
      
     #+begin_src python :results output
       def is_even(n):
           if n == 0:
               return True
           else:
               return is_odd(n-1)

       def is_odd(n):
           if n == 0:
               return False
           else:
               return is_even(n-1)

       result = is_even(4)
     #+end_src 

***** Env analysis

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-18 23:20:17
      [[file:Recursion/screenshot_2019-03-18_23-20-17.png]]
 
***** Multually recursive to single recursive
      *Mutually* recursive functions can be turned into a *single* recursive function by *breaking the abstraction boundary* between the two functions. 

      #+begin_src python :results output
        def is_even(n):
            if n == 0:
                return True
            else:
                if (n-1) == 0:
                    return False
                else:
                    return is_even((n-1)-1)
      #+end_src 

      - *put base cases together* and pass *next updated para* to the *remaining func*.
      - *mutual* recursion provides a *mechanism* for *maintaining abstraction* within a *complicated(single)* recursive program.
****** Question:                                                  :QUESTIONS:
       1. 怎么理解 *breaking the abstraction boundary* ？是不是就是 *put base cases together* ？
*** 1.7.3 Printing in Recursive Functions
**** Using calls to ~print~ to visualize the computational process evolved by a recursive function 
***** Example: ~cascade~ to print all prefixes of a number from largest to smallest to largest.

      #+begin_src python :results output
        def cascade(n):
            """Print a cascade of prefixes of n."""
            if n < 10:
                print(n)
            else:
                print(n)
                cascade(n//10)
                print(n)
            """simplify"""
            print(n)
            if n >= 10:
                cascade(n//10)
                print(n)
      #+end_src 

***** Example: multual recursion for two-player game

      #+begin_src python :results output
        def play_alice(n):
            if n == 0:
                print("Bob wins!")
            else:
                play_bob(n-1)
    
        def play_bob(n):
            if n == 0:
                print("Alice wins!")
            elif is_even(n):
                play_alice(n-2)
            else:
                play_alice(n-1)
      #+end_src 

      - A natural *decomposition*: *encapsulating* each strategy in its own func
        - Modifying one strategy *without affecting* the other, maintaining the *abstraction barrier* between the two.
      - Turn-by-turn: these two funcs call each other at the end of each turn.
*** 1.7.4 Tree Recursion
    *Tree Recursive*: A func with *multiple* recursive calls

    #+begin_src python :results output
      def fib(n):
          if n == 1:
              return 0
          if n == 2:
              return 1
          else:
              return fib(n-2) + fib(n-1)

      result = fib(6)
    #+end_src 

    - As for Fibonacci, *iterative* is more *efficient* than *recursive*.
*** 1.7.5 Example: Partitions
    The *number of partitions* of a positive integer /n/, using parts *up to* size /m/, is the number of ways in which /n/ can be expressed as the *sum* of positive integer parts up to /m/ in *increasing order*.
    - Strategy: the number of ways to partition /n/ using integers up to /m/ equals
      1. the number of ways to partition /n-m/ using integers up to /m/, and
      2. the number of ways to partition /n/ using integers up to /m-1/
     
    #+begin_src python :results output
      def count_partitions(n, m):
          """Count the ways to partition n using parts up to m."""
          if n == 0:
              return 1
          elif n < 0:
              return 0
          elif m == 0:
              return 0
          else:
              return count_partitions(n-m, m) + count_partitions(n, m-1)
    #+end_src 

    - *Recursively reducing* the problem of partitioning /n/ using integers up to /m/ into *two simpler problems*:
      1. partition a *smaller number* /n-m/
      2. partition with *smaller components* up to /m-1/
    - *Base cases*:
      1. There is one way to partition 0: include no parts.
      2. There are 0 ways to partition a negative n.
      3. There are 0 ways to partition any n greater than 0 using parts of size 0 or less.
    - Thinking of a *tree-recursive* func as *exploring different possibilities*: using a part of size m and not m in this case
**** Question:                                                    :QUESTIONS:
     1. 从数学上怎么解决上面的拆数问题？递归&非递归思路？
     2. 怎么理解上面的递归思路？包括base cases的确定？
     3. 怎么用非递归方法实现代码?

* Chapter 2: Building Abstractions with Data
** 2.1 Introduction
*** 2.1.1 Native Data Types
**** Native data types' properties: 
       1. There are *expressions* that evaluate to *values* of native types, called *literals*.
       2. There are *built-in functions and operators* to manipulate *values* of native types.
**** Native numeric types:
       1. ~int~ for integers
       2. ~float~ for real numbers (approximation)
          1. there are *minimum* and *maximum* values
          2. only a *finite* amount of *precision*
          3. dividing one ~int~ by another yields a ~float~ value
          4. combining ~float~ values can lead to *approximation errors*: ~7 / 3 * 3~ => ~7.0~; ~1 / 3 * 7 * 3~ => ~6.999999999999999~
          5. Problems with this *approximation* appear when conducting equality tests: ~1/3 == 0.333333333333333312345~ => ~True~  
       3. ~complex~ for complex numbers 

**** Non-numeric types
     Values can represent many other types of data, such as sounds, images, locations, web addresses, network connections, and more.
     - *A few* are represented by *native data types*, such as the ~bool~ class for values ~True~ and ~False~
     - The type for *most* values must be defined by programmers using the means of *combination and abstraction*
** 2.2 Data Abstraction
   1. The general technique of *isolating*
      - the parts of a program that deal with how *data are represented* from
      - the parts that deal with how *data are manipulated* 
   2. func vs data abstraction
      - func abstraction: make an abstraction that separates the way the function *is used* from the details of how the function *is implemented*
      - data abstraction: make an abstraction that isolates how a *compound data* value *is used* from the details of how it *is constructed*
   3. basic idea of data abstraction: structure programs as *two parts* which are *connected* by a small set of *funcs that implement abstract data in terms of the concrete representation* 
      1. the part that *operates on abstract data*
      2. the part that *defines a concrete representation*
*** 2.2.1 Example: Rational Numbers
    Rational numbers: ~<numerator>/<denominator>~ 
**** wishful thinking assumptions before defining:
     - ~rational(n, d)~ returns the rational number with numerator ~n~ and denominator ~d~.
     - ~numer(x)~ returns the numerator of the rational number ~x~.
     - ~denom(x)~ returns the denominator of the rational number ~x~.
     - operations on rational nums:
       #+begin_src python :results output
         def add_rationals(x, y):
             nx, dx = numer(x), denom(x)
             ny, dy = numer(y), denom(y)
             return rational(nx * dy + ny * dx, dx * dy)

         def mul_rationals(x, y):
             return rational(numer(x) * numer(y), denom(x) * denom(y))

         def print_rational(x):
             print(numer(x), '/', denom(x))

         def rationals_are_equal(x, y):
             return numer(x) * denom(y) == numer(y) * denom(x)
       #+end_src 

*** 2.2.2 Pairs
**** Compound structure ~list~ 
     #+begin_src python :results output
       def rational(n, d):
           return [n, d]

       def numer(x):
           return x[0]

       def denom(x):
           return x[1]
     #+end_src 
**** Reduce rational nums constructed above to lowest terms
     changing the *constructor* ~rational()~  without changing any of the functions that implement the actual arithmetic *operations*

     #+begin_src python :results output
       from fractions import gcd
       def rational(n, d):
           g = gcd(n, d)
           return (n//g, d//g)
     #+end_src 

*** 2.2.3 Abstraction Barriers
    - General underlying idea of data abstraction:
      1. identify a *basic set of operations* in terms of which *all manipulations* of values of some kind will be *expressed*
      2. then to use *only those operations* in manipulating the data
      By restricting the use of operations in this way, it is much easier to *change the representation* of abstract data *without changing the behavior of a program*.
    - An *abstraction barrier* is a rule that funcs should be *called by a higher level* and *implemented using a lower level* of abstraction *instead of called directly by a lower level* of abstraction *when possible*.
      - Abstraction barrier *violation* example: computing the square of a rational num
        - Implemented by ~mul_rational~
        
          #+begin_src python :results output
            def square_rational(x):
                return mul_rational(x, x)
          #+end_src

        - Referring directly to numerators and denominators would violate *one abstraction barrier*

          #+begin_src python :results output
            def square_rational_violating_once(x):
                return rational(numer(x) * numer(x), denom(x) * denom(x))
          #+end_src

        - Assuming that rationals are represented as two-element lists would violate *two abstraction barriers*

          #+begin_src python :results output
            def square_rational_violating_twice(x):
                return [x[0] * x[0], x[1] * x[1]]
          #+end_src 
      - Abstraction barriers make programs easier to *maintain and to modify*
        The *fewer* functions that *depend on a particular representation*, the *fewer* changes are required when one wants to *change* that representation
        - ~square_rational~ doesn't require updating even if the representation of rational nums changed
        - ~square_rational_violating_once~ require updating whenever the *selector or constructor signatures* changed
        - ~square_rational_violating_twice~ require updating whenever the *implementation* of rational numbers changed 




*** 2.2.4 The Properties of Data
    As long as *behavior conditions* are met (no matter how *implementation* details below an abstraction barrier changes) $\Rightarrow$ *selectors and constructors* can constitute and remain a *valid representation* of abstract data
    - Example: *functional* representation for rational nums
      - *"pair" behavior condition*: If a pair ~p~ was constructed from values ~x~ and ~y~, then ~select(p, 0)~ returns ~x~, and ~select(p, 1)~ returns ~y~
      - implement two functions ~pair~ and ~select~ that *met behavior condition* above
       
        #+begin_src python :results output
          def pair(x, y):
              """Return a function that represents a pair."""
              def get(index):
                  if index == 0:
                      return x
                  elif index == 1:
                      return y
              return get

          def select(p, i):
              """Return the element at index i of pair p."""
              return p(i)
        #+end_src
       
      - Functional representations are *sufficient but obscure* to represent *compound data* ("pair" here) 
    - The practice of data abstraction allows *switching among representations* easily.

** 2.3 Sequences
   A sequence is an *ordered collection* of values. Sequences are *instances of a collection of behaviors* that are *shared among several different types of data*. In particular,
   - Length - A sequence has a *finite* length. An empty sequence has length 0.
   - Element selection - A sequence has an *element corresponding to any non-negative integer index* less than its length, starting at *0 for the first element*
*** 2.3.1 Lists
    - ~len~ and element seletion
      #+begin_src python :results output
        digits = [1, 8, 2, 8]
        len(digits)
        4
        digits[3]
        8
      #+end_src
    - Addition and multiplication
      #+begin_src python :results output
        [2, 7] + digits * 2
        [2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
      #+end_src
    - Lists can be included in a list
      #+begin_src python :results output
        pairs = [[10, 20], [30, 40]]
        pairs[1]
        [30, 40]
        pairs[1][0]
        30
      #+end_src
*** 2.3.2 Sequence Iteration
    - ~for~ statement 
      #+begin_src python :results output
        for <name> in <expression>:
            <suite>
      #+end_src
      - ~<expression>~ refers to ~iterable values~. Lists are a type of *sequence*, and *sequences* are ~iterable values~
      - The ~for~ loop introduces yet another way in which the *environment* can be updated by a *statement*
    - Sequence unpacking
      A ~for~ statement may include *multiple names* in its header to *"unpack"* each element sequence into its respective elements
      #+begin_src python :results output
        pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
        same_count = 0
        for x, y in pairs:
                if x == y:
                    same_count = same_count + 1

        same_count
        2
      #+end_src
    - Ranges
      A ~range~ is another built-in type of sequence in Python, which represents a *range of integers*
      #+begin_src python :results output
        list(range(5, 8))
        [5, 6, 7]
        list(range(4))
        [0, 1, 2, 3]
      #+end_src
      - ~Ranges~ commonly appear as the *expression* in a ~for~ header to specify the number of times that the *suite* should be executed
        #+begin_src python :results output
          for _ in range(3):
              print('Go Bears!')

          Go Bears!
          Go Bears!
          Go Bears!
        #+end_src
        - A common convention among programmers: using ~_~ for the name in the ~for~ header if the name is *unused* in the suite
*** 2.3.3 Sequence Processing
    - Common patterns in sequence processing
      - List Comprehensions: Evaluating a fixed expression for *each element* in a sequence and collecting the resulting values in a *result sequence*
        #+begin_src python :results output
          odds = [1, 3, 5, 7, 9]
          [x+1 for x in odds]
          [2, 4, 6, 8, 10]
        #+end_src     
      - Selecting a subset of values that *satisfy some condition*
        #+begin_src python :results output
          [x for x in odds if 25 % x == 0]
          [1, 5]
        #+end_src
        - General form ~[<map expression> for <name> in <sequence expression> if <filter expression>]~
          - ~<sequence expression>~ must return an *iterable* value
          - Values of the ~map expression~ are collected into a *list*         
      - Aggregation: aggregating *all values* in a sequence into a *single value* 
        - Divisors
          #+begin_src python :results output
            def divisors(n):
                return [1] + [x for x in range(2, n) if n % x == 0]
             divisors(4)
            [1, 2]
             divisors(12)
            [1, 2, 3, 4, 6]
          #+end_src
        - Perfect numbers
          #+begin_src python :results output
            [n for n in range(1, 1000) if sum(divisors(n)) == n]
            [6, 28, 496]
          #+end_src    
        - Given a rectangle's area, finding the minimum premeter of it with integer side lengths
          #+begin_src python :results output
            def width(area, height):
                assert area % height == 0
                return area // height
             def perimeter(width, height):
                return 2 * width + 2 * height
             def minimum_perimeter(area):
                heights = divisors(area)
                perimeters = [perimeter(width(area, h), h) for h in heights]
                return min(perimeters)
             area = 80
            width(area, 5)
            16
            perimeter(16, 5)
            42
            perimeter(10, 8)
            36
            minimum_perimeter(area)
            36
            [minimum_perimeter(n) for n in range(1, 10)]
            [4, 6, 8, 8, 12, 10, 16, 12, 12]
          #+end_src
          - ~heights = divisors(area)~ and ~perimeters = [perimeter(width(area, h), h) for h in heights]~ return lists
    - Using Higher-Order Function
      - Evaluating an expression for each element (List Comprehensions)
        #+begin_src python :results output
          def apply_to_all(map_fn, s):
              return [map_fn(x) for x in s]
        #+end_src
      - Selecting only elements for which some expression is true
        #+begin_src python :results output
          def keep_if(filter_fn, s):
              return [x for x in s if filter_fn(x)]
        #+end_src
      - Repeatedly applying a *two-argument function* to the ~reduced~ value so far and each element (Aggregation)
        #+begin_src python :results output
          def reduce(reduce_fn, s, initial):
              reduced = initial
              for x in s:
                  reduced = reduce_fn(reduced, x)
              return reduced
        #+end_src
        - Multiplying together all elements of a sequence
          #+begin_src python :results output
            reduce(mul, [2, 4, 8], 1)
            64
          #+end_src
        - Perfect num
          #+begin_src python :results output
            def divisors_of(n):
                divides_n = lambda x: n % x == 0
                return [1] + keep_if(divides_n, range(2, n))

            divisors_of(12)
            [1, 2, 3, 4, 6]

            from operator import add
            def sum_of_divisors(n):
                return reduce(add, divisors_of(n), 0)

            def perfect(n):
                return sum_of_divisors(n) == n

            keep_if(perfect, range(1, 1000))
            [1, 6, 28, 496]
          #+end_src 
    - Conventional Names
      - ~map~ for ~apply_to_all~ and ~filter~ for ~keep_if~
        In Python, the *built-in* ~map~ and ~filter~ are generalizations of these functions that *do not return lists*.
        #+begin_src python :results output
          apply_to_all = lambda map_fn, s: list(map(map_fn, s))
          keep_if = lambda filter_fn, s: list(filter(filter_fn, s))
        #+end_src
      - The ~reduce~ function is built into the ~functools~ module of the Python standard library
        #+begin_src python :results output
          from functools import reduce
          from operator import mul
          def product(s):
              return reduce(mul, s)

          product([1, 2, 3, 4, 5])
          120
        #+end_src 
*** 2.3.4 Sequence Abstraction
    Two *native data types* that satisfy the *sequence abstraction*: ~lists~ and ~ranges~
    - Length and element selection: ~length~ and ~[]~  
    - Membership
    - Slicing
*** 2.3.5 Strings

*** 2.3.6 Trees

*** 2.3.7 Linked Lists

** 2.4 Mutable Data 



* Funcs
** Expressions
*** Types of expressions
    An expression describes a computation and evaluates to a value
**** Primitive expressions
     ~2 + 1~
**** Call expressions
     ~max(2,3)~
*** Call Expressions in Python
    All expressions can use func call notation
    ~max(2,3)~
*** Anatomy of a Call Expression
    Evaluation procedure for call expressions:
    ~add(2, 3)~ 
    Operators and operands are also expressions, so they evaluate to values.
**** Evaluate the operator and then the operand subexpressions

    | operator | add |
    | operand1 |   2 |
    | operand2 |   3 |

**** Apply the func that is the value of the operator subexpression to the args that are the values of the operand subexpression

    | func  | value of add |
    | arg1 | value of 2   |
    | arg2 | value of 3   |

*** Evaluating Nested Expressions
   ~mul(add(4,mul(4, 6)), add(3, 5))~ 

   #+BEGIN_SRC dot :file ./func-1.png :exports results
     digraph func1 {
           a1 [label="mul(add(4,mul(4, 6)), add(3, 5))"];
           a2 [label="add(4,mul(4,6))"];
           a3 [label="add(3,5)"];
           a5 [label="mul(4,6)"];
           4 [shape=box];
           6 [shape=box];
           3 [shape=box];
           5 [shape=box];
           a1->a2->4;
           a2->a5->4;
           a5->6;
           a1->a3->3;
           a3->5;
     }     
   #+END_SRC

   #+RESULTS:
   [[file:./func-1.png]]

** Funcs, Values, Objects, Interpreters, and Data
*** Objects

    #+BEGIN_SRC python :session Objects :results output
      from urllib.request import urlopen
      shakes = urlopen('http://composingprograms.com/shakespeare.txt')
      text = shakes.read().split()
    #+END_SRC 

    #+BEGIN_SRC python :session Objects :results output
      print(len(text),'\n',text[:25],'\n', text.count(b'the'), '\n', text.count(b','))
    #+END_SRC 

    #+RESULTS:
    : 980637 
    :  [b'A', b"MIDSUMMER-NIGHT'S", b'DREAM', b'Now', b',', b'fair', b'Hippolyta', b',', b'our', b'nuptial', b'hour', b'Draws', b'on', b'apace', b':', b'four', b'happy', b'days', b'bring', b'in', b'Another', b'moon', b';', b'but', b'O'] 
    :  23272 
    :  81827

*** Sets 

    #+BEGIN_SRC python :session Objects :results output
      words = set(text)
      print(len(words),'\n',max(words))
    #+END_SRC 

    #+RESULTS:
    : 33505 
    :  b'zwaggered'

*** Reversals 

    #+BEGIN_SRC python :session Objects :results output
      print('draw'[::-1])
      print({w for w in words if w == w[::-1] and len(w)>4})
      print({w for w in words if w[::-1] in words and len(w) == 4})
      print({w for w in words if w[::-1] in words and len(w) > 6})
    #+END_SRC 

    #+RESULTS:
    : ward
    : {b'rever', b'madam', b'level', b'minim', b'redder', b'refer'}
    : {b'noon', b'snip', b'tops', b'smug', b'garb', b'maws', b'rail', b'flow', b'trap', b'ward', b'doom', b'rood', b'drab', b'dial', b'sees', b'stab', b'leer', b'keel', b'lees', b'wort', b'mood', b'spin', b'stop', b'leek', b'meed', b'loop', b'star', b'draw', b'teem', b'liar', b'poop', b'trow', b'gums', b'spot', b'gnat', b'room', b'elle', b'door', b'hoop', b'tang', b'bard', b'swam', b'live', b'pooh', b'deed', b'laid', b'rats', b'evil', b'seel', b'nips', b'brag', b'ecce', b'pool', b'spit', b'part', b'tips', b'pots', b'moor', b'meet', b'esse', b'peep', b'reel', b'deem', b'pins', b'wolf', b'deer', b'port', b'trop', b'bats', b'reed'}
    : set()
     
* Names
** Env Diagrams
*** Env Diagrams
    Env diagrams visualize the interpreter’s process.
**** Code
     Statements and expressions

     #+BEGIN_SRC python 
       from math import pi
       tau = 2 * pi
       return pi, tau
     #+END_SRC 

     #+RESULTS:
     | 3.141592653589793 | 6.283185307179586 |

**** Frames
     Each name is bound to a value. Within a frame, a name cannot be repeated

    | Global frame |        |
    |--------------+--------|
    | name         |  value |
    | pi           | 3.1416 |
    | tau          | 6.2832 |

*** Assignment Statements
**** Execution rule for assignment statements:
     - Evaluate all expressions to the right of = from left to right.
     - Bind all names to the left of = to those resulting values in the current frame.
       
     #+BEGIN_SRC python :results output
       a = 1
       b = 2
       b, a = a + b, b
       print(a,b)
     #+END_SRC

     #+RESULTS:
     : 2 3

** Defining Funcs
*** Defining Funcs
    Assignment is a simple means of abstraction: binds names to values
    Func def is a more powerful means of abstraction: binds names to expressions
    
    #+BEGIN_SRC python
      def <name>(<formal parameters>): 
          return <return expression>
    #+END_SRC

**** Execution procedure for def statements:
     1. Create a func with signature ~<name>(<formal parameters>)~, func signature indicates how many args a func takes, it has all the
information needed to create a local frame.
     2. Set the body of that func to be everything indented after the first line, func body defines the computation performed when the func is applied
     3. Bind ~<name>~ to that func in the current frame
*** Calling User-Defined Funcs
**** Procedure for calling/applying user-defined funcs
     1. Add a local frame, forming a new env
     2. Bind the func's formal parameters to its args in that frame
     3. Execute the body of the func in that new env
*** Looking Up Names In Env
    Every expression is evaluated in the context of an env. So far, the current env is either: 
    - The global frame alone, or
    - A local frame, followed by the global frame. 
**** Most important two things:
     1. An env is a sequence of frames. 
     2. A name evaluates to the value bound to that name in the earliest frame of the current env in which that name is found.
* Control
** Print and None
*** None Indicates that Nothing is Returned
   - The special value ~None~ represents nothing in Python
   - A func that does not explicitly return a value will return ~None~
   - Careful: ~None~ is not displayed by the interpreter as the value of an expression
     
    #+begin_src python 
      def does_not_return_square(a):
          a*a
      x = does_not_return_square(4) + 3 
      return x
    #+end_src

*** Pure Funcs & Non-Pure Funcs
**** Pure Funcs
     just return *values*: ~abs()~   
     
     #+begin_src python 
       return abs(-2)
     #+end_src

     #+RESULTS:
     : 2

**** Non-Pure Funcs     
     return *values(None)* and have *side effects*: ~print()~

     #+begin_src python :results output
       a = print(2)
       print(a)
     #+end_src

     #+RESULTS:
     : 2
     : None

*** Nested Expressions with Print
    
    #+begin_src python :results output
      a = print(print(1), print(2))
      print(a)
    #+end_src

    #+RESULTS:
    : 1
    : 2
    : None None
    : None
    
** Multiple Envs
*** Life Cycle of a User-Defined Func 
**** Def statement:

     #+begin_src python
       def square(x):
           return mul(x, x)
     #+end_src
    
     - A new func is created!
     - Name bound to that func in the current frame 
**** Call expression: 
     ~square(2+2)~ 
     - Operator & operands evaluated
     - Func (value of operator) called on args (values of operands):
**** Calling/Applying: 
     - A new frame is created!
     - Body is executed in that new env
*** Multiple Envs in One Diagram!
    
    #+BEGIN_SRC python :results output
      from operator import mul
      def square(x):
          return mul(x, x);
      print(square(square(3)))
    #+END_SRC 

    #+RESULTS:
    : 81

    An env is a sequence of frames.
    - The global frame alone
    - A local, then the global frame
    *One env per frame here* 
**** ENV1 

     | Frames | Global      |
     | funcs  | mul, square |

**** ENV2

     | Frames       | f2: square [parent=Global |
     | x            |                         3 |
     | return value |                         9 |

**** ENV3

     | Frames       | f3: square [parent=Global |
     | x            |                         9 |
     | return value |                        81 |

*** Names Have No Meaning Without Envs
    - Every expression is evaluated in the context of an env.
    - A name evaluates to the value bound to that name in the earliest frame of the current env in which that name is found.
*** Names Have Different Meanings in Different Envs
    
    #+BEGIN_SRC python :results output
      from operator import mul
      def square(square):
          return mul(square, square)
      print(square(4))
    #+END_SRC 

    #+RESULTS:
    : 16

    *A call expression and the body of the func being called are evaluated in different envs*

    | call of square(4) | ENV1:Global                |
    | body of square(4) | ENV2:f1 followed by Global |

** Miscellaneous Python Features
*** Operators
**** Addition 

     #+BEGIN_SRC python :results output
       print(2+3*4+5,'\n',(2+3)*(4+5))
     #+END_SRC 

     #+RESULTS:
     : 19 
     :  45

**** Division

     #+BEGIN_SRC python :results output
       print(618 / 10, 618 // 10, 618 % 10)
       from operator import truediv, floordiv, mod
       print(truediv(618, 10), floordiv(618, 10), mod(618, 10))
     #+END_SRC 

     #+RESULTS:
     : 61.8 61 8
     : 61.8 61 8

*** Multiple Return Values 

    #+BEGIN_SRC python :results output
      def divide_exact(n, d):
          return n // d, n % d
      quotient, remainder = divide_exact(618, 10)
      print(quotient, remainder)
    #+END_SRC 

    #+RESULTS:
    : 61 8

*** Docstrings, doctests, & default args
    use *python3 -m doctest test.py* to doctest. 

    #+BEGIN_SRC python :results output
      def divide_exact(n, d=10):
          """Return the quotient and remainder of dividing N by D.

          >>> quotient, remainder = divide_exact(618, 10)
          >>> quotient
          61
          >>> remainder
          8
          """
          return floordiv(n, d), mod(n, d)
    #+END_SRC 

*** Conditional Statements
**** Statements
     A *statement* is executed by the *interpreter* to perform an action

**** Compound statements 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-05 16:46:10
     [[file:Control/screenshot_2019-03-05_16-46-10.png]]
 
     The first header determins a *statement's type*: ~def~ ~if~ ~while~...
 
**** Conditional Statements

     #+begin_src python :results output
       def absolute_value(x):
           if x < 0:
               return -x
           elif x == 0:
               return0
           else:
               return x
     #+end_src 
      
     1 statement, 3 clauses, 3 headers, 3 suites.

**** Boolean Contexts
     In python

     | False | False, 0, '', None, [], ... |
     | True  | Not false                   |

*** Iteration
**** While Statements
      
     #+begin_src python :results output
       i,total = 0, 0
       while i < 3:
           i = i + 1
           total = total + 1
     #+end_src 

**** Example: The Fibonacci Sequence
      
     #+begin_src python :results output
       def fib(n):
           """Compute the nth Fibonacci number"""
           pred, curr = 0, 1 #--> pred, curr = 1, 0
           k = 1             #--> k = 0
           while k < n:
               pred, curr = curr, pred + curr
               k = k + 1
           return curr
     #+end_src 
      
* Higher-Order Func
* Envs
* Iteration
* Recursion
* Func Examples
* Tree Recursion
* Data Abstraction
* Containers
* Trees
* Mutable Values
* Mutable Funcs
* Iterators
* Objects
* Inheritance
* Representation
* Growth

