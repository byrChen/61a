* Funcs
** Lecture1
*** Expressions
**** Types of expressions
     An expression describes a computation and evaluates to a value
***** Primitive expressions
      ~2 + 1~
***** Call expressions
      ~max(2,3)~
**** Call Expressions in Python
     All expressions can use func call notation
     ~max(2,3)~
**** Anatomy of a Call Expression
     Evaluation procedure for call expressions:
     ~add(2, 3)~ 
     Operators and operands are also expressions, so they evaluate to values.
***** Evaluate the operator and then the operand subexpressions

     | operator | add |
     | operand1 |   2 |
     | operand2 |   3 |

***** Apply the func that is the value of the operator subexpression to the args that are the values of the operand subexpression

     | func  | value of add |
     | arg1 | value of 2   |
     | arg2 | value of 3   |

**** Evaluating Nested Expressions
    ~mul(add(4,mul(4, 6)), add(3, 5))~ 

    #+BEGIN_SRC dot :file ./func-1.png :exports results
      digraph func1 {
            a1 [label="mul(add(4,mul(4, 6)), add(3, 5))"];
            a2 [label="add(4,mul(4,6))"];
            a3 [label="add(3,5)"];
            a5 [label="mul(4,6)"];
            4 [shape=box];
            6 [shape=box];
            3 [shape=box];
            5 [shape=box];
            a1->a2->4;
            a2->a5->4;
            a5->6;
            a1->a3->3;
            a3->5;
      }     
    #+END_SRC

    #+RESULTS:
    [[file:./func-1.png]]

*** Funcs, Values, Objects, Interpreters, and Data
**** Objects

     #+BEGIN_SRC python :session Objects :results output
       from urllib.request import urlopen
       shakes = urlopen('http://composingprograms.com/shakespeare.txt')
       text = shakes.read().split()
     #+END_SRC 

     #+BEGIN_SRC python :session Objects :results output
       print(len(text),'\n',text[:25],'\n', text.count(b'the'), '\n', text.count(b','))
     #+END_SRC 

     #+RESULTS:
     : 980637 
     :  [b'A', b"MIDSUMMER-NIGHT'S", b'DREAM', b'Now', b',', b'fair', b'Hippolyta', b',', b'our', b'nuptial', b'hour', b'Draws', b'on', b'apace', b':', b'four', b'happy', b'days', b'bring', b'in', b'Another', b'moon', b';', b'but', b'O'] 
     :  23272 
     :  81827

**** Sets 

     #+BEGIN_SRC python :session Objects :results output
       words = set(text)
       print(len(words),'\n',max(words))
     #+END_SRC 

     #+RESULTS:
     : 33505 
     :  b'zwaggered'

**** Reversals 

     #+BEGIN_SRC python :session Objects :results output
       print('draw'[::-1])
       print({w for w in words if w == w[::-1] and len(w)>4})
       print({w for w in words if w[::-1] in words and len(w) == 4})
       print({w for w in words if w[::-1] in words and len(w) > 6})
     #+END_SRC 

     #+RESULTS:
     : ward
     : {b'rever', b'madam', b'level', b'minim', b'redder', b'refer'}
     : {b'noon', b'snip', b'tops', b'smug', b'garb', b'maws', b'rail', b'flow', b'trap', b'ward', b'doom', b'rood', b'drab', b'dial', b'sees', b'stab', b'leer', b'keel', b'lees', b'wort', b'mood', b'spin', b'stop', b'leek', b'meed', b'loop', b'star', b'draw', b'teem', b'liar', b'poop', b'trow', b'gums', b'spot', b'gnat', b'room', b'elle', b'door', b'hoop', b'tang', b'bard', b'swam', b'live', b'pooh', b'deed', b'laid', b'rats', b'evil', b'seel', b'nips', b'brag', b'ecce', b'pool', b'spit', b'part', b'tips', b'pots', b'moor', b'meet', b'esse', b'peep', b'reel', b'deem', b'pins', b'wolf', b'deer', b'port', b'trop', b'bats', b'reed'}
     : set()
     
* Names
** Lecture2
*** Env Diagrams
**** Env Diagrams
     Env diagrams visualize the interpreter’s process.
***** Code
      Statements and expressions

      #+BEGIN_SRC python 
        from math import pi
        tau = 2 * pi
        return pi, tau
      #+END_SRC 

      #+RESULTS:
      | 3.141592653589793 | 6.283185307179586 |

***** Frames
      Each name is bound to a value. Within a frame, a name cannot be repeated

     | Global frame |        |
     |--------------+--------|
     | name         |  value |
     | pi           | 3.1416 |
     | tau          | 6.2832 |

**** Assignment Statements
***** Execution rule for assignment statements:
      - Evaluate all expressions to the right of = from left to right.
      - Bind all names to the left of = to those resulting values in the current frame.
       
      #+BEGIN_SRC python :results output
        a = 1
        b = 2
        b, a = a + b, b
        print(a,b)
      #+END_SRC

      #+RESULTS:
      : 2 3

*** Defining Funcs
**** Defining Funcs
     Assignment is a simple means of abstraction: binds names to values
     Func def is a more powerful means of abstraction: binds names to expressions
    
     #+BEGIN_SRC python
       def <name>(<formal parameters>): 
           return <return expression>
     #+END_SRC

***** Execution procedure for def statements:
      1. Create a func with signature ~<name>(<formal parameters>)~, func signature indicates how many args a func takes, it has all the
 information needed to create a local frame.
      2. Set the body of that func to be everything indented after the first line, func body defines the computation performed when the func is applied
      3. Bind ~<name>~ to that func in the current frame
**** Calling User-Defined Funcs
***** Procedure for calling/applying user-defined funcs
      1. Add a local frame, forming a new env
      2. Bind the func's formal parameters to its args in that frame
      3. Execute the body of the func in that new env
**** Looking Up Names In Env
     Every expression is evaluated in the context of an env. So far, the current env is either: 
     - The global frame alone, or
     - A local frame, followed by the global frame. 
***** Most important two things:
      1. An env is a sequence of frames. 
      2. A name evaluates to the value bound to that name in the earliest frame of the current env in which that name is found.
* Control
** Lecture3
*** Print and None
**** None Indicates that Nothing is Returned
    - The special value ~None~ represents nothing in Python
    - A func that does not explicitly return a value will return ~None~
    - Careful: ~None~ is not displayed by the interpreter as the value of an expression
     
     #+begin_src python 
       def does_not_return_square(a):
           a*a
       x = does_not_return_square(4) + 3 
       return x
     #+end_src

**** Pure Funcs & Non-Pure Funcs
***** Pure Funcs
      just return *values*: ~abs()~   
     
      #+begin_src python 
        return abs(-2)
      #+end_src

      #+RESULTS:
      : 2

***** Non-Pure Funcs     
      return *values(None)* and have *side effects*: ~print()~

      #+begin_src python :results output
        a = print(2)
        print(a)
      #+end_src

      #+RESULTS:
      : 2
      : None

**** Nested Expressions with Print
    
     #+begin_src python :results output
       a = print(print(1), print(2))
       print(a)
     #+end_src

     #+RESULTS:
     : 1
     : 2
     : None None
     : None
    
*** Multiple Envs
**** Life Cycle of a User-Defined Func 
***** Def statement:

      #+begin_src python
        def square(x):
            return mul(x, x)
      #+end_src
    
      - A new func is created!
      - Name bound to that func in the current frame 
***** Call expression: 
      ~square(2+2)~ 
      - Operator & operands evaluated
      - Func (value of operator) called on args (values of operands):
***** Calling/Applying: 
      - A new frame is created!
      - Body is executed in that new env
**** Multiple Envs in One Diagram!
    
     #+BEGIN_SRC python :results output
       from operator import mul
       def square(x):
           return mul(x, x);
       print(square(square(3)))
     #+END_SRC 

     #+RESULTS:
     : 81

     An env is a sequence of frames.
     - The global frame alone
     - A local, then the global frame
     *One env per frame here* 
***** ENV1 

      | Frames | Global      |
      | funcs  | mul, square |

***** ENV2

      | Frames       | f2: square [parent=Global |
      | x            |                         3 |
      | return value |                         9 |

***** ENV3

      | Frames       | f3: square [parent=Global |
      | x            |                         9 |
      | return value |                        81 |

**** Names Have No Meaning Without Envs
     - Every expression is evaluated in the context of an env.
     - A name evaluates to the value bound to that name in the earliest frame of the current env in which that name is found.
**** Names Have Different Meanings in Different Envs
    
     #+BEGIN_SRC python :results output
       from operator import mul
       def square(square):
           return mul(square, square)
       print(square(4))
     #+END_SRC 

     #+RESULTS:
     : 16

     *A call expression and the body of the func being called are evaluated in different envs*

     | call of square(4) | ENV1:Global                |
     | body of square(4) | ENV2:f1 followed by Global |

*** Miscellaneous Python Features
**** Operators
***** Addition 

      #+BEGIN_SRC python :results output
        print(2+3*4+5,'\n',(2+3)*(4+5))
      #+END_SRC 

      #+RESULTS:
      : 19 
      :  45

***** Division

      #+BEGIN_SRC python :results output
        print(618 / 10, 618 // 10, 618 % 10)
        from operator import truediv, floordiv, mod
        print(truediv(618, 10), floordiv(618, 10), mod(618, 10))
      #+END_SRC 

      #+RESULTS:
      : 61.8 61 8
      : 61.8 61 8

**** Multiple Return Values 

     #+BEGIN_SRC python :results output
       def divide_exact(n, d):
           return n // d, n % d
       quotient, remainder = divide_exact(618, 10)
       print(quotient, remainder)
     #+END_SRC 

     #+RESULTS:
     : 61 8

**** Docstrings, doctests, & default args
     use *python3 -m doctest test.py* to doctest. 

     #+BEGIN_SRC python :results output
       def divide_exact(n, d=10):
           """Return the quotient and remainder of dividing N by D.

           >>> quotient, remainder = divide_exact(618, 10)
           >>> quotient
           61
           >>> remainder
           8
           """
           return floordiv(n, d), mod(n, d)
     #+END_SRC 

**** Conditional Statements
***** Statements
      A *statement* is executed by the *interpreter* to perform an action

***** Compound statements 

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-05 16:46:10
      [[file:Control/screenshot_2019-03-05_16-46-10.png]]
 
      The first header determins a *statement's type*: ~def~ ~if~ ~while~...
 
***** Conditional Statements

      #+begin_src python :results output
        def absolute_value(x):
            if x < 0:
                return -x
            elif x == 0:
                return0
            else:
                return x
      #+end_src 
      
      1 statement, 3 clauses, 3 headers, 3 suites.

***** Boolean Contexts
      In python

      | False | False, 0, '', None, [], ... |
      | True  | Not false                   |

**** Iteration
***** While Statements
      
      #+begin_src python :results output
        i,total = 0, 0
        while i < 3:
            i = i + 1
            total = total + 1
      #+end_src 

***** Example: The Fibonacci Sequence
      
      #+begin_src python :results output
        def fib(n):
            """Compute the nth Fibonacci number"""
            pred, curr = 0, 1 #--> pred, curr = 1, 0
            k = 1             #--> k = 0
            while k < n:
                pred, curr = curr, pred + curr
                k = k + 1
            return curr
      #+end_src 
      
* Higher-Order Func
** 1.6 Higher-Order Funcs
   Funcs that *manipulate funcs* are called *higher-order funcs*
*** 1.6.1 Funcs as Args
   
    #+begin_src python :results output
      def sum_naturals(n):
              total, k = 0, 1
              while k <= n:
                  total, k = total + k, k + 1
              return total

      def sum_cubes(n):
              total, k = 0, 1
              while k <= n:
                  total, k = total + k*k*k, k + 1
              return total

      def pi_sum(n):
              total, k = 0, 1
              while k <= n:
                  total, k = total + 8 / ((4*k-3) * (4*k-1)), k + 1
              return total

      def summation(n, term):
              total, k = 0, 1
              while k <= n:
                  total, k = total + term(k), k + 1
              return total

      def identity(x):
              return x

      def sum_naturals(n):
              return summation(n, identity)

      def cube(x):
          return x*x*x

      def sum_cubes(n):
          return summation(n, cube)

      def pi_term(x):
              return 8 / ((4*x-3) * (4*x-1))

      def pi_sum(n):
              return summation(n, pi_term)
    #+end_src 

*** 1.6.2 Funcs as General Methods
**** A more powerful kind of abstraction in higher-order funcs
     Some funcs express *general methods of computation*, *independent of the particular funcs* they call.

     #+begin_src python :results output
       def improve(update, close, guess=1):
               while not close(guess):
                   guess = update(guess)
               return guess

       def golden_update(guess):
               return 1/guess + 1

       def square_close_to_successor(guess):
               return approx_eq(guess * guess, guess + 1)

       def approx_eq(x, y, tolerance=1e-15):
               return abs(x - y) < tolerance

       phi = improve(golden_update,square_close_to_successor)
     #+end_src 

     - This ~improve~ func is a *general expression* of repetitive refinement.It *doesn't specify* what problem is being solved: those *details* are left to the ~update~ and ~close~ funcs passed in as args.
     - When a user-defined func is *applied* to some args, the formal parameters are bound to the values of those arguments (which *may be funcs*) in a *new local frame*.
     
     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-11 07:28:36
     [[file:1.6%20Higher-Order%20Funcs/screenshot_2019-03-11_07-28-36.png]]

**** Two related big ideas in computer science
     - *Naming and funcs* allow us to *abstract away* a vast amount of *complexity*.
     - Only an *extremely general evaluation procedure* for the Python language can make *small components* composed into *complex processes*.
   
**** A test to check its correctness. 

     #+begin_src python :results output
       from math import sqrt
       phi = 1/2 + sqrt(5)/2
       def improve_test():
               approx_phi = improve(golden_update, square_close_to_successor)
               assert approx_eq(phi, approx_phi), 'phi differs from its approximation'

       improve_test()
     #+end_src 

*** 1.6.3 Defining Funcs III: Nested Defs
**** Problems of passing funcs as args
     Pass functions as arguments significantly *enhances the expressive power* of python.
*****  Two problems 
      - *Global frame* becomes *cluttered with names* of small functions, which must all be *unique*.
      - We are *constrained by particular function signatures*.(the ~update~ argument to ~improve~ must take exactly *one argument*.)
**** Nested func def address problems above
***** Example: square root of a number
   
      #+begin_src python :results output
        def average(x, y):
            return (x + y)/2

        def improve(update, close, guess=1):
            while not close(guess):
                guess = update(guess)
            return guess

        def approx_eq(x, y, tolerance=1e-3):
            return abs(x - y) < tolerance

        def sqrt(a):
            def sqrt_update(x):
                return average(x, a/x)
            def sqrt_close(x):
                return approx_eq(x * x, a)
            return improve(sqrt_update, sqrt_close)

        result = sqrt(256)
      #+end_src 

****** Env review
******* Most important two things:
        1. An env is a sequence of frames. 
        2. A name evaluates to the value bound to that name in the earliest frame of the current env in which that name is found.
******* Life Cycle of a User-Defined Func 
******** Def statement:
         - Name bound to that func in the current frame 
******** Calling/Applying: 
         - A new frame is created!
         - Body is executed in that new env
****** Env analysis

       #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-11 13:03:05
       [[file:1.6%20Higher-Order%20Funcs/screenshot_2019-03-11_13-03-05.png]]

       | Env                     | Frame(created when calling func)           | Func evaluated within frame               | Arg evaluted within frame                            |
       | Env1                    | Global                                     | ~average~, ~improve~, ~approx_eq~, ~sqrt~ | None                                                 |
       | Env2 extended from Env1 | f1: ~sqrt~ [parent=Global                  | ~sqrt_update~, ~sqrt_close~               | a=256                                                |
       | Env3 extended from Env1 | f2: ~improve~ [parent=Global               | None                                      | update= ~sqrt_update~, close= ~sqrt_close~ , guess=1 |
       | Env4 extended from Env2 | f3: ~sqrt_close~ [parent=f1 [parent=Global | None                                      | x=1, a=256(from parent f1)                           |
       | Env5 extended from Env1 | f4: ~approx_eq~ [parent=Global             | None                                      | x=1, y=256, tolerance=0.001                          |
     
       #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-11 13:05:31
       [[file:1.6%20Higher-Order%20Funcs/screenshot_2019-03-11_13-05-31.png]]  
 
       | Env                     | Frame(created when calling func)            | Func evaluated within frame               | Arg evaluted within frame                            |
       | Env1                    | Global                                      | ~average~, ~improve~, ~approx_eq~, ~sqrt~ | None                                                 |
       | Env2 extended from Env1 | f1: ~sqrt~ [parent=Global                   | ~sqrt_update~, ~sqrt_close~               | a=256                                                |
       | Env3 extended from Env1 | f2: ~improve~ [parent=Global                | None                                      | update= ~sqrt_update~, close= ~sqrt_close~ , guess=1 |
       | Env6 extended from Env2 | f5: ~sqrt_update~ [parent=f1 [parent=Global | None                                      | x=1, a=256(from parent f1)                           |
       | Env7 extended from Env1 | f6: ~average~ [parent=Global                | None                                      | x=1, y=256                                           |

****** Lexical scope
       The *inner funcs* have access to the *names* in the env where they are *defined* (*not* where they are *called*).
******* Two extensions to our env model to enable lexical scoping
        - Each user-defined func has a *parent env*: the environment in which it was *defined*.
        - When a user-defined func is *called*, its *local frame extends its parent env*.
******* Two key advantages of lexical scoping in Python
        - The *names of a local func* do *not interfere* with *names external* to the function in which it is *defined*, because the local function name will be bound in the *current local env* in which it was *defined*, rather than the *global environment*.
        - A local func can *access the env* of the *enclosing func*, because the *body of the local func* is evaluated in an env that *extends the evaluation environment* in which it was *defined*.

*** 1.6.4 Funcs as Returned Values
    Funcs as returned values can achieve more *expressive power*.
**** Example: function *composition* h(x) = f(g(x))

    #+begin_src python :results output
      def square(x):
          return x*x

      def successor(x):
          return x + 1

      def composel(f, g):
          def h(x):
              return f(g(x))
          return h

      def f(x):
          """Never called"""
          return -x

      square_successor = composel(square, successor)
      result = square_successor(12)
    #+end_src 

***** Env analysis

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-12 09:30:50
      [[file:1.6%20Higher-Order%20Funcs/screenshot_2019-03-12_09-30-50.png]]
 
      | Env                     | Frame(created when calling func)  | Func evaluated within frame                                | Arg evaluted within frame   |
      | Env1                    | Global                            | ~square~, ~successor~, ~compose1~, ~f~, ~square_successor~ | None                        |
      | Env2 extended from Env1 | f1: ~compose1~ [parent=Global     | ~h~                                                        | f= ~square~, g= ~successor~ |
      | Env3 extended from Env2 | f2: ~h~ [parent=f1 [parent=Global | None                                                       | x=12                        |
      | Env4 extended from Env1 | f3: ~successor~ [parent=Global    | None                                                       | x=12                        |
      | Env5 extended from Env1 | f4: ~square~ [parent=Global       | None                                                       | x=13                        |
     
      - ~f~ and ~g~ are ~resolved correctly~, even in the presence of *conflicting* names(~f~ defined in Global frame).
      - An important feature of *lexically scoped* programming languages: *locally defined* functions *maintain* their *parent environment* when they are *returned* (when return ~f(g(x))~, ~f~ and ~g~ are found from parent frame f1)
***** Question:
      1. 怎么结合env分析比较好的描述程序执行过程？包括环境之间的跳转，返回等。用哪种方式，dot画环境跳转、参数传递、返回值和拓展关系图可行吗？

*** 1.6.5 Example: Newton's Method
    This extended example shows how function *return values and local definitions* can *work together* to express general ideas concisely.
**** Square root

     #+begin_src python :results output
       def improve(update, close, guess=1):
           while not close(guess):
               guess = update(guess)
           return guess

       def approx_eq(x, y, tolerance=1e-3):
           return abs(x - y) < tolerance

       def newton_update(f, df):
           def update(x):
               return x - f(x) / df(x)
           return update

       def find_zero(f, df):
           def near_zero(x):
               return approx_eq(f(x), 0)
           return improve(newton_update(f, df), near_zero)

       def square_root_newton(a):
           def f(x):
               return x * x - a
           def df(x):
               return 2 * x
           return find_zero(f, df)

       square_root_newton(64)
     #+end_src 

**** Nth root

     #+begin_src python :results output
       def improve(update, close, guess=1):
           while not close(guess):
               guess = update(guess)
           return guess

       def approx_eq(x, y, tolerance=1e-3):
           return abs(x - y) < tolerance

       def newton_update(f, df):
           def update(x):
               return x - f(x) / df(x)
           return update

       def find_zero(f, df):
           def near_zero(x):
               return approx_eq(f(x), 0)
           return improve(newton_update(f, df), near_zero)

       def power(x, n):
           """Return x*x*x*...*x for x repeated n times."""
           product, k = 1, 0
           while k < n:
               product, k = product * x, k + 1
           return product

       def nth_root_of_a(n, a):
           def f(x):
               return power(x, n) - a
           def df(x):
               return n * power(x, n-1)
           return find_zero(f, df)

       nth_root_of_a(3, 64)
     #+end_src 

**** Question:
     1. 仍然是怎么结合env分析清晰的整理程序执行过程？特别是在参数传递和返回值环节。
*** 1.6.6 Currying
    Use *higher-order functions* to convert *a function* that takes *multiple arguments* into *a chain of functions* that each take *a single argument*.
**** Example 1: manual currying

     #+begin_src python :results output
       def curried_pow(x):
           def h(y):
               return pow(x, y)
           return h


       def map_to_range(start, end, f):
           while start < end:
               print(f(start))
               start = start + 1


       map_to_range(0, 10, curried_pow(2))
     #+end_src 

     - ~curried_pow(x)(y)~ = ~pow(x, y)~
**** Example 2: automate currying

     #+begin_src python :results output
       def curry2(f):
           """Return a curried version of the given two-argument function."""
           def g(x):
               def h(y):
                   return f(x, y)
               return h
           return g


       def uncurry2(g):
           """Return a two-argument version of the given curried function."""
           def f(x, y):
               return g(x)(y)
           return f


       def map_to_range(start, end, f):
           while start < end:
               print(f(start))
               start = start + 1


       pow_curried = curry2(pow)
       map_to_range(0, 10, pow_curried(2))
       uncurry2(pow_curried)(2, 5)
     #+end_src 

     - ~curry2(f)(x)(y)~ = ~f(x, y)~
     - ~uncurry2(curry2(f))~ = ~f~ 
**** Question:
     1. 什么情况下需要curry？为何不直接最外用多个形参？结合嵌套函数的参数传递方式理解curry的传参方式？
     2. 结合env分析？
    
*** 1.6.7 Lambda Expressions
    A lambda expression evaluates to a function that has a single return expression as its body. Assignment and control statements are not allowed.
    - ~lambda x: f(g(x))~: A *function* that takes ~x~ and *returns* ~f(g(x))~.
    - The *result* of a *lambda expression* is called a *lambda function*: ~<function <lambda> at 0xf3f490>~.
**** Example 1: compose with ~lambda~ expressions

     #+begin_src python :results output
       def compose1(f, g):
           return lambda x: f(g(x))

       f = compose1(lambda x: x * x, lambda y: y + 1)

       result = f(12)
     #+end_src 

*****  Env analysis
 
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-12 16:45:59
      [[file:1.6%20Higher-Order%20Funcs/screenshot_2019-03-12_16-45-59.png]]
 
**** Example 2: *compound* ~lambda~ expressions
    
     #+begin_src python :results output
       compose1 = lambda f,g: lambda x: f(g(x))
     #+end_src 

**** Question:
     1. Example 1中结合env分析过程？
     2. Example 2的理解？ 

*** 1.6.8 Abstractions and First-Class Funcs
    - *Higher-order funcs* can *represent abstractions explicitly as elements* so they can be handled like other *computational elements*.
    - *Elements* with the *fewest restrictions* are said to have *first-class status*.Some of the "rights and privileges" of first-class elements are:
      1. They may be *bound to names*.
      2. They may be *passed as arguments to functions*.
      3. They may be *returned as the results of functions*.
      4. They may be *included in data structures*.
    - Python awards *functions full first-class status*.
   
*** 1.6.9 Func Decorators
    Python provides *special syntax* to apply *higher-order functions* as *part of executing a def statement*, called a *decorator*.
**** Example 1: trace

     #+begin_src python :results output
       def trace(fn):
           def wrapped(x):
               print('-> ', fn, '(', x, ')')
               return fn(x)
           return wrapped

       @trace  # or triple = trace(triple)
       def triple(x):
           return 3 * x

       triple(12)
     #+end_src 
    
     - A higher-order function ~trace~ returns a function that *precedes a call to its argument* with a print statement that *outputs the argument*.
     - With ~@trace~, name ~triple~ is bound to the ~returned function value~ of *calling ~trace~ on the newly defined ~triple~ function*: ~trace(triple(12))~.
**** Extra for experts
     The decorator symbol @ may also be followed by a call expression. The expression following @ is evaluated first (just as the name trace was evaluated above), the def statement second, and finally the result of evaluating the decorator expression is applied to the newly defined function, and the result is bound to the name in the def statement.
**** Question:
     1. Extra for experts的理解？decorator用在什么地方？用内存去追踪程序吗？
** Lecture4
* Envs
** 1.6 
** Lecture5
* Iteration
* Recursion
** 1.7 Recursive Funcs
   A function is called *recursive* if the *body of the function calls the function itself*, either *directly or indirectly*. 

   #+begin_src python :results output
     def sum_digits(n):
         """Return the sum of the digits of positive integer n."""
         if n < 10:
             return n
         else:
             all_but_last, last = n // 10, n % 10
             return sum_digits(all_but_last) + last
   #+end_src 
   
   Two steps:
   - Summing all but the last digit: ~sum_digits(all_but_last)~.
   - Adding the last digit: ~sum_digits(all_but_last) + last~.
    
   Env analysis:
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-18 14:04:32
   [[file:Recursion/screenshot_2019-03-18_14-04-32.png]]

*** 1.7.1 The Anatomy of Recursive Functions
    *Base cases* + *recursive calls*: to express computation by *simplifying problems incrementally*.
**** Example: *Recursion* vs *Iteration* 

     #+begin_src python :results output
       def fact_iter(n):
           total, k = 1, 1
           while k <= n:
               total, k = total * k, k + 1
           return total

       def fact(n):
           if n == 1:
               return 1
           else:
               return n * fact(n-1)
     #+end_src 
     
***** Env analysis(only recursion)

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-18 21:22:51
      [[file:Recursion/screenshot_2019-03-18_21-22-51.png]]
      
***** Differences
      *Recursive* functions leverage the *rules of evaluating call expressions* to *bind names to values*, often *avoiding the nuisance* of *correctly assigning local names* during *iteration*. 
****** Computation cases
       - Recursion
       *final to base*: *complicate to simple*.
       - Iteration
       *final to base or base to final*: *identical*.
****** Name and frame numbers:
       - Recursion
       *less names(usually one)* but *more frames*: bind *different values* to *less names* in *different frames* to *track to characterize computation state* and return values from *all frames one by one(base to final)*.
       - Iteration
       *more names* but *less frames(usually one)*: *explicitly track some names* to *characterize computation state* and *return other names* once in *less frames*.
****** Correctness varification:
       - Recursion
       *trust simpler cases* and *only check final*: treat *recursive calls(simpler cases)* as *functional abstraction*, a form of proof by *induction*.
       - Iteration
       
****** Question        
       1. 怎么检查iteration的正确?检查base开头和final结尾并trust中间过程？
*** 1.7.2 Mutual Recursion
    When a recursive procedure is *divided among two functions* that *call each other*, the functions are said to be *mutually recursive*. 
**** Example: even or odd for non-negative integers
     - a number is *even* if it is *one more than* an *odd* number
     - a number is odd if it is *one more than* an *even* number
     - 0 is even
      
     #+begin_src python :results output
       def is_even(n):
           if n == 0:
               return True
           else:
               return is_odd(n-1)

       def is_odd(n):
           if n == 0:
               return False
           else:
               return is_even(n-1)

       result = is_even(4)
     #+end_src 

***** Env analysis

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-18 23:20:17
      [[file:Recursion/screenshot_2019-03-18_23-20-17.png]]
 
     
***** Multually recursive to single recursive
      *Mutually* recursive functions can be turned into a *single* recursive function by *breaking the abstraction boundary* between the two functions. 

      #+begin_src python :results output
        def is_even(n):
            if n == 0:
                return True
            else:
                if (n-1) == 0:
                    return False
                else:
                    return is_even((n-1)-1)
      #+end_src 

      - *put base cases together* and pass *next updated para* to the *remaining func*.
      - *mutual* recursion provides a *mechanism* for *maintaining abstraction* within a *complicated(single)* recursive program.
****** Question:
       1. 怎么理解 *breaking the abstraction boundary* ？是不是就是 *put base cases together* ？
*** 1.7.3 Printing in Recursive Functions
**** Using calls to ~print~ to visualize the computational process evolved by a recursive function 
***** Example: ~cascade~ to print all prefixes of a number from largest to smallest to largest.

      #+begin_src python :results output
        def cascade(n):
            """Print a cascade of prefixes of n."""
            if n < 10:
                print(n)
            else:
                print(n)
                cascade(n//10)
                print(n)
      #+end_src 

*** 1.7.4 Tree Recursion
*** 1.7.5 Example: Partitions
* Func Examples
* Tree Recursion
* Data Abstraction
* Containers
* Trees
* Mutable Values
* Mutable Funcs
* Iterators
* Objects
* Inheritance
* Representation
* Growth
