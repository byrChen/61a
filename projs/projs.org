* Project 1: The Game of Hog
** Phase 1: Simulator
*** Problem 0
    #+begin_src python :results output
      def make_test_dice(*outcomes):
          """Return a die that cycles deterministically through OUTCOMES.

          >>> dice = make_test_dice(1, 2, 3)
          >>> dice()
          1
          >>> dice()
          2
          >>> dice()
          3
          >>> dice()
          1
          >>> dice()
          2

          This function uses Python syntax/techniques not yet covered in this course.
          The best way to understand it is by reading the documentation and examples.
          """
          assert len(outcomes) > 0, 'You must supply outcomes to make_test_dice'
          for o in outcomes:
              assert type(o) == int and o >= 1, 'Outcome is not a positive integer'
          index = len(outcomes) - 1
          def dice():
              nonlocal index
              index = (index + 1) % len(outcomes)
              return outcomes[index]
          return dice
    #+end_src 
    1. ~assert~
    2. func as return value: ~four_sided()~, ~six_sided()~
    3. ~*outcomes~
    4. ~for o in outcomes:~
    5. ~nonlocal~
*** Problem 1
    #+begin_src python :results output
      def roll_dice(num_rolls, dice=six_sided):
          """Simulate rolling the DICE exactly NUM_ROLLS > 0 times. Return the sum of
          the outcomes unless any of the outcomes is 1. In that case, return 1.

          num_rolls:  The number of dice rolls that will be made.
          dice:       A function that simulates a single dice roll outcome.
          """
          # These assert statements ensure that num_rolls is a positive integer.
          assert type(num_rolls) == int, 'num_rolls must be an integer.'
          assert num_rolls > 0, 'Must roll at least once.'
          # BEGIN PROBLEM 1
          "*** YOUR CODE HERE ***"
          sum, sum_1, i = 0, 0, 0
          while i < num_rolls:
              i += 1
              a = dice()
              if (a == 1 or sum_1 == 1):
                  sum_1 = 1
                  continue
              else:
                  sum += a

          return sum_1 if sum_1 else sum
          # END PROBLEM 1
    #+end_src 

    1. ~sum, sum_1, i = 0, 0, 0~
    2. ~a = dice()~
    3. ~return sum_1 if sum_1 else sum~
*** Problem 3
    #+begin_src python :results output
      def take_turn(num_rolls, opponent_score, dice=six_sided):
          """Simulate a turn rolling NUM_ROLLS dice, which may be 0 (Free Bacon).
          Return the points scored for the turn by the current player.

          num_rolls:       The number of dice rolls that will be made.
          opponent_score:  The total score of the opponent.
          dice:            A function that simulates a single dice roll outcome.
          """
          # Leave these assert statements here; they help check for errors.
          assert type(num_rolls) == int, 'num_rolls must be an integer.'
          assert num_rolls >= 0, 'Cannot roll a negative number of dice in take_turn.'
          assert num_rolls <= 10, 'Cannot roll more than 10 dice.'
          assert opponent_score < 100, 'The game should be over.'
          # BEGIN PROBLEM 3
          "*** YOUR CODE HERE ***"
          return roll_dice(num_rolls, dice) if num_rolls else free_bacon(opponent_score)
          # END PROBLEM 3
    #+end_src 

    1. ~roll_dice(num_rolls, dice)~ not ~roll_dice(num_rolls, dice=six_sided)~
    2. ~return roll_dice(num_rolls, dice) if num_rolls else free_bacon(opponent_score)~ 
*** Problem 4
    #+begin_src python :results output
      def is_swap(player_score, opponent_score):
          """
          Return whether the current player's score has the same absolute
          difference between its last two digits as the opponent's score.
          """
          # BEGIN PROBLEM 4
          "*** YOUR CODE HERE ***"
          return abs(player_score % 100 // 10 - player_score % 100 % 10) == abs(opponent_score % 100 // 10 - opponent_score % 100 % 10)
          # END PROBLEM 4
    #+end_src 

    1. *No need(no way)* to swap ~player_score~ and ~opponent_score~ , only return ~True~ or ~False~. 
*** Problem 5
    #+begin_src python :results output
      def play(strategy0, strategy1, score0=0, score1=0, dice=six_sided,
               goal=GOAL_SCORE, say=silence):
          """Simulate a game and return the final scores of both players, with Player
          0's score first, and Player 1's score second.

          A strategy is a function that takes two total scores as arguments (the
          current player's score, and the opponent's score), and returns a number of
          dice that the current player will roll this turn.

          strategy0:  The strategy function for Player 0, who plays first.
          strategy1:  The strategy function for Player 1, who plays second.
          score0:     Starting score for Player 0
          score1:     Starting score for Player 1
          dice:       A function of zero arguments that simulates a dice roll.
          goal:       The game ends and someone wins when this score is reached.
          say:        The commentary function to call at the end of the first turn.
          """
          player = 0  # Which player is about to take a turn, 0 (first) or 1 (second)
          # BEGIN PROBLEM 5
          "*** YOUR CODE HERE ***"
          while score0 < goal and score1 < goal:
              if not player:
                  score0 += take_turn(strategy0(score0, score1), score1, dice)
              else:
                  score1 += take_turn(strategy1(score1, score0), score0, dice)
              player = other(player)
              if is_swap(score0, score1):
                  score0, score1 = score1, score0

          # END PROBLEM 5
          # (note that the indentation for the problem 6 prompt (***YOUR CODE HERE***) might be misleading)
          # BEGIN PROBLEM 6
          "*** YOUR CODE HERE ***"
          # END PROBLEM 6
          return score0, score1
    #+end_src 
    1. ~strategy0(score0, score1)~ and ~strategy1(score1,score0)~
    2. no need 
       #+begin_src python :results output
         if not player:
         #    if score0 >= goal:
         #       break
             score0 += take_turn(strategy0(score0, score1), score1, dice)
       #+end_src
       wrong
       #+begin_src python :results output
         if not player:
             score0 += take_turn(strategy0(score0, score1), score1, dice)
         #    if score0 >= goal:
         #       break
       #+end_src
    3. One iteration for one ~take_turn()~ + one ~is_swap()~
    4. ~score0, score1 = score1, score0~ 
** Phase 2: Commentary
*** Commentary examples
    #+begin_src python :results output
      def say_scores(score0, score1):
          """A commentary function that announces the score for each player."""
          print("Player 0 now has", score0, "and Player 1 now has", score1)
          return say_scores

      def announce_lead_changes(previous_leader=None):
          """Return a commentary function that announces lead changes.

          >>> f0 = announce_lead_changes()
          >>> f1 = f0(5, 0)
          Player 0 takes the lead by 5
          >>> f2 = f1(5, 12)
          Player 1 takes the lead by 7
          >>> f3 = f2(8, 12)
          >>> f4 = f3(8, 13)
          >>> f5 = f4(15, 13)
          Player 0 takes the lead by 2
          """
          def say(score0, score1):
              if score0 > score1:
                  leader = 0
              elif score1 > score0:
                  leader = 1
              else:
                  leader = None
              if leader != None and leader != previous_leader:
                  print('Player', leader, 'takes the lead by', abs(score0 - score1))
              return announce_lead_changes(leader)
          return say

      def both(f, g):
          """Return a commentary function that says what f says, then what g says.

          >>> h0 = both(say_scores, announce_lead_changes())
          >>> h1 = h0(10, 0)
          Player 0 now has 10 and Player 1 now has 0
          Player 0 takes the lead by 10
          >>> h2 = h1(10, 6)
          Player 0 now has 10 and Player 1 now has 6
          >>> h3 = h2(6, 17) # Player 0 gets 7 points, then Swine Swap applies
          Player 0 now has 6 and Player 1 now has 17
          Player 1 takes the lead by 11
          """
          def say(score0, score1):
              return both(f(score0, score1), g(score0, score1))
          return say
    #+end_src 

    1. ~say_scores~ returns a reference to itself.
    2. ~announce_lead_changes~ and ~both~ are *high order* funcs.
    3. ~func~ vs ~func()~: ~a = func~ means *a is a func* while ~a = func()~ means *a is a value* which = *return value(may also a func)* of ~func()~.
    4. *Details*:
       - ~say_scores(a, b)~ = ~say_scores~.
       - ~announce_lead_changes()~ = ~announce_lead_changes(previous_leader)~ = ~say~; ~say(a, b)~ = ~announce_leader_changes(leader)~ = ~say~.
       - ~both(say_scores, announce_lead_changes())~ = ~both(say_scores, say)~ = ~say~; ~say(a, b)~ = ~both(say_scores(a, b), announce_lead_changes(a, b))~ = ~both(say_scores(a, b), say(a, b))~ = ~both(say_scores, say)~ = ~say~.
**** Question:                                                    :QUESTIONS:
     1. 关于 ~func~ 与 ~func()~ 的分析？
     2. 如上关于评论函数的分析正误？有没有更简洁的理解分析？
*** Problem 6
    #+begin_src python :results output
      def play(strategy0, strategy1, score0=0, score1=0, dice=six_sided,
               goal=GOAL_SCORE, say=silence):
          """Simulate a game and return the final scores of both players, with Player
          0's score first, and Player 1's score second.

          A strategy is a function that takes two total scores as arguments (the
          current player's score, and the opponent's score), and returns a number of
          dice that the current player will roll this turn.

          strategy0:  The strategy function for Player 0, who plays first.
          strategy1:  The strategy function for Player 1, who plays second.
          score0:     Starting score for Player 0
          score1:     Starting score for Player 1
          dice:       A function of zero arguments that simulates a dice roll.
          goal:       The game ends and someone wins when this score is reached.
          say:        The commentary function to call at the end of the first turn.
          """
          player = 0  # Which player is about to take a turn, 0 (first) or 1 (second)
          # BEGIN PROBLEM 5
          "*** YOUR CODE HERE ***"
          first_turn = 1

          while score0 < goal and score1 < goal:
              if not player:
                  score0 += take_turn(strategy0(score0, score1), score1, dice)
              else: # get score1
                  score1 += take_turn(strategy1(score1, score0), score0, dice)

              if is_swap(score0, score1):
                  score0, score1 = score1, score0

              if first_turn:
                  commment_func = say(score0, score1)
                  first_turn = 0
              else:
                  commment_func = commment_func(score0, score1)

              # Switch player
              player = other(player)
          # END PROBLEM 5
          # (note that the indentation for the problem 6 prompt (***YOUR CODE HERE***) might be misleading)
          # BEGIN PROBLEM 6
          "*** YOUR CODE HERE ***"
          # END PROBLEM 6
          return score0, score1

    #+end_src 

    1. A commentary function is called *at the end of each turn*, the *only side effect* of a commentary function should be to *print*, *no any return values*.
    2. The *return value of calling a commentary function* gives you the *commentary function to call on the next turn*: ~comment_func~ = ~say(score0, score1)~ = ~say~; ~comment_func(score0, score1)~ = ~say(score0, score1)~ = ~say~ = ~comment_func~.

*** Problem 7
    #+begin_src python :results output
      def announce_highest(who, previous_high=0, previous_score=0):
          """Return a commentary function that announces when WHO's score
          increases by more than ever before in the game.

          >>> f0 = announce_highest(1) # Only announce Player 1 score gains
          >>> f1 = f0(12, 0)
          >>> f2 = f1(12, 11)
          11 point(s)! That's the biggest gain yet for Player 1
          >>> f3 = f2(20, 11)
          >>> f4 = f3(13, 20) # Player 1 gets 2 points, then Swine Swap applies
          >>> f5 = f4(20, 35) # Player 0 gets 22 points, then Swine Swap applies
          15 point(s)! That's the biggest gain yet for Player 1
          >>> f6 = f5(20, 47) # Player 1 gets 12 points; not enough for a new high
          >>> f7 = f6(21, 47)
          >>> f8 = f7(21, 77)
          30 point(s)! That's the biggest gain yet for Player 1
          >>> f9 = f8(77, 22) # Swap!
          >>> f10 = f9(33, 77) # Swap!
          55 point(s)! That's the biggest gain yet for Player 1
          """
          assert who == 0 or who == 1, 'The who argument should indicate a player.'
          # BEGIN PROBLEM 7
          "*** YOUR CODE HERE ***"
          def say(score0, score1, pre_score = previous_score, pre_high = previous_high):
              if who == 0:
                  if score0 - pre_score > pre_high:
                      pre_high = score0 - previous_score
                      print(pre_high, "point(s)! That's the biggest gain yet for Player", who)
                  pre_score = score0
              else:
                  if score1 - pre_score > pre_high:
                      pre_high = score1 - previous_score
                      print(pre_high, "point(s)! That's the biggest gain yet for Player", who)
                  pre_score = score1
              return announce_highest(who, pre_high, pre_score)
          return say
    #+end_src 
    
    1. Use ~nonlocal~ or ~say(score0, score1, pre_score = previous_score, pre_high = previous_high)~ to avoid ~local variable [var] reference before assignment~ error. 
    2. Commentary func: ~announce_highest(who, previous_high, previous_score)~ = ~say~; ~say(a, b)~ = ~announce_highest(who, previous_high, previous_score)~ = ~say~.

*** Problem 8
    #+begin_src python :results output
      def make_averaged(fn, num_samples=1000):
          """Return a function that returns the average value of FN when called.

          To implement this function, you will have to use *args syntax, a new Python
          feature introduced in this project.  See the project description.

          >>> dice = make_test_dice(4, 2, 5, 1)
          >>> averaged_dice = make_averaged(dice, 1000)
          >>> averaged_dice()
          3.0
          """
          # BEGIN PROBLEM 8
          "*** YOUR CODE HERE ***"
          def fn_average(*args):
              sum, i = 0, 0
              while i < num_samples:
                  sum += fn(*args)
                  i += 1
              return sum / num_samples

          return fn_average
    #+end_src 

    1. ~make_average~ is a *higher order func* as it *both takes in a function as an argument* and *returns a function*.
    2. ~*args~ to accept an *arbitrary* number of args.

*** Problem 9
    #+begin_src python :results output
      def max_scoring_num_rolls(dice=six_sided, num_samples=1000):
          """Return the number of dice (1 to 10) that gives the highest average turn
          score by calling roll_dice with the provided DICE over NUM_SAMPLES times.
          Assume that the dice always return positive outcomes.

          >>> dice = make_test_dice(1, 6)
          >>> max_scoring_num_rolls(dice)
          1
          """
          # BEGIN PROBLEM 9
          # num = 1
          # if dice == 1:
          #     num = 1
          # else:
          #     while dice != 1:
          #         num += 1
          #         if num == 10:
          #             break
          # return num
          num = 2
          min = 1
          while num <= 10:
              score = make_averaged(roll_dice, num_samples)
              if score(num, dice) > score(min, dice):
                  min = num
              num += 1
          return min
          "*** YOUR CODE HERE ***"
    #+end_src 

    1. ~make_averaged~ returns a *func*, not ~if make_averaged(roll_dice(num, dice), num_samples) > make_averaged(roll_dice(min, dice), num_samples)~.
    2. ~score = make_averaged(roll_dice, num_samples)~ and ~score(num, dice)~.
    3. Computing average win rate in ~average_win_rate~: ~win_rate_as_player_0 = 1 - make_averaged(winner)(strategy, baseline)~ and ~win_rate_as_player_1 = make_averaged(winner)(baseline, strategy)~.
    4. ~run_experiments()~ has *no return value*.
**** Question:                                                    :QUESTIONS:
     1. 为什么 ~run_experiments()~ 没有返回值？什么情况下允许无返回值？为什么 ~comment_function~ 不能没有返回值直接 ~print~ ？
** Phase 3: Strategies
*** Problem 10
    #+begin_src python :results output
      def bacon_strategy(score, opponent_score, margin=8, num_rolls=4):
          """This strategy rolls 0 dice if that gives at least MARGIN points, and
          rolls NUM_ROLLS otherwise.
          """
          # BEGIN PROBLEM 10
          return 0 if free_bacon(score) >= margin and free_bacon(opponent_score) >= margin else num_rolls  # Replace this statement
    #+end_src 

    1. This strategy *rolls 0 dice* if that *gives at least MARGIN points*, and *rolls NUM_ROLLS otherwise*: ~return 0 if free_bacon(score) >= margin and free_bacon(opponent_score) >= margin else num_rolls~

*** Problem 11
    #+begin_src python :results output
      def swap_strategy(score, opponent_score, margin=8, num_rolls=4):
          """This strategy rolls 0 dice when it triggers a beneficial swap. It also
          rolls 0 dice if it gives at least MARGIN points and does not trigger a
          non-beneficial swap. Otherwise, it rolls NUM_ROLLS.
          """
          # BEGIN PROBLEM 11
          score += free_bacon(opponent_score)

          if is_swap(score, opponent_score):
              if score < opponent_score:
                  return 0
              elif score == opponent_score and free_bacon(opponent_score) >= margin:
                  return 0
              else:
                  return num_rolls
          elif free_bacon(opponent_score) >= margin:
              return 0
          else:
              return num_rolls

          # if is_swap(score, opponent_score):
          #     if score < opponent_score:
          #         return 0
          #     else:
          #         return num_rolls
          # elif free_bacon(opponent_score) >= margin:
          #     return 0
          # else:
          #     return num_rolls

          # return 0 if (is_swap(score, opponent_score) and score < opponent_score) or (not is_swap(score, opponent_score) and free_bacon(opponent_score) >= margin) else num_rolls
    #+end_src 

    1. Way1:

       #+begin_src python :results output
         if is_swap(score, opponent_score):
             if score < opponent_score:
                 return 0
             elif score == opponent_score and free_bacon(opponent_score) >= margin:
                 return 0
             else:
                 return num_rolls
         elif free_bacon(opponent_score) >= margin:
             return 0
         else:
             return num_rolls
       #+end_src

    2. Way2:

       #+begin_src python :results output
         if is_swap(score, opponent_score):
             if score < opponent_score:
                 return 0
             else:
                 return num_rolls
         elif free_bacon(opponent_score) >= margin:
             return 0
         else:
             return num_rolls

       #+end_src

    3. Way3:

       #+begin_src python :results output
         return 0 if (is_swap(score, opponent_score) and score < opponent_score) or (not is_swap(score, opponent_score) and free_bacon(opponent_score) >= margin) else num_rolls
       #+end_src 

**** Question:                                                   :QUESTIONS:
     1. 方法一是逻辑上覆盖最全面的，但方法二也能跑通，是方法一可以减少冗余还是方法二未覆盖全面？
     2. 方法三使用 ~return a if b else c~ 改写的方法二，实际工作中用哪种风格比较好？

*** Optional: Problem 12                                        :OUTSTANDING:
    #+begin_src python :results output
    #+end_src 
* Project 2: Yelp Maps 
** Phase 0: Utilities
*** Problem 0
**** Test cases
     #+begin_src python :results output
       map_and_filter(['hi', 'hello', 'hey', 'world'], lambda x: x[4], lambda x: len(x) > 4)
       ['o', 'd']

       min([-2, -1, 0, 1, 2], key=lambda x: x*x)
       0
       min([[0, 3], [1, 2], [2, 1]], key=lambda x: x[1])
       [2, 1]

       min({-1: 6, 0: 5, 1: 4})
       -1
       min({-1: 6, 0: 5, 1: 4}, key=lambda x: x*x)
       0
       key_of_min_value({-1: 6, 0: 5, 1: 4})
       1
       min({'a': 6, 'b': 5, 'c': 4}) # Strings are compared by alphabetical ordering of characters
       'a'
       key_of_min_value({'a': 6, 'b': 5, 'c': 4})
       'c'

       xs = [6, 1, 4] 
       ys = [2, 6, 2]
       for x, y in EXPR:
       ...     print(x + y)
       8
       7
       6
       EXPR = zip(xs, ys)
     #+end_src 
     - ~'abcde'[4]~ = ~'e'~
     - ~min~: ~min(iterable, *iterables[,key, default])~ and ~min(arg1, arg2, *args[, key])~  
     - ~x, y = zip([1, 2], [3, 4])~ -> 2 *tuples* ~x = (1, 3)~ and ~y = (2, 4)~    
**** Problem 0.2: Using min
     #+begin_src python :results output
       def key_of_min_value(d):
           """Returns the key in a dict d that corresponds to the minimum value of d.

           >>> letters = {'a': 6, 'b': 5, 'c': 4, 'd': 5}
           >>> min(letters)
           'a'
           >>> key_of_min_value(letters)
           'c'
           """
           # BEGIN Question 0
           return min(d, key=d.get)
     #+end_src 
     - ~min(d, key=d.get)~ 
**** Problem 0.3: Using zip
     #+begin_src python :results output
       def zip(*sequences):
           """Returns a list of lists, where the i-th list contains the i-th
           element from each of the argument sequences.

           >>> zip(range(0, 3), range(3, 6))
           [[0, 3], [1, 4], [2, 5]]
           >>> for a, b in zip([1, 2, 3], [4, 5, 6]):
           ...     print(a, b)
           1 4
           2 5
           3 6
           >>> for triple in zip(['a', 'b', 'c'], [1, 2, 3], ['do', 're', 'mi']):
           ...     print(triple)
           ['a', 1, 'do']
           ['b', 2, 're']
           ['c', 3, 'mi']
           """
           return list(map(list, _zip(*sequences)))

       def enumerate(s, start=0):
           """Returns a list of lists, where the i-th list contains i+start and
           the i-th element of s.

           >>> enumerate([6, 1, 'a'])
           [[0, 6], [1, 1], [2, 'a']]
           >>> enumerate('five', 5)
           [[5, 'f'], [6, 'i'], [7, 'v'], [8, 'e']]
           """
           # BEGIN Question 0
           "*** YOUR CODE HERE ***"
           return zip(list(range(start, start + len(s))), s)
     #+end_src 
     - ~list(map(list, _zip(*sequences)))~
     - ~zip(list(range(start, start + len(s))), s)~ 
** Phase 1: Data Abstraction
*** Problem 2
    #+begin_src python :results output
      def make_restaurant(name, location, categories, price, reviews):
          """Return a restaurant data abstraction containing the name, location,
          categories, price, and reviews for that restaurant."""
          # BEGIN Question 2
          "*** YOUR CODE HERE ***"
          return {'name': name, 'location': location, 'categories': categories, 'price': price, 'reviews': reviews}

      def restaurant_ratings(restaurant):
          """Return a list of ratings, which are numbers from 1 to 5, of the
          restaurant based on the reviews of the restaurant."""
          # BEGIN Question 2
          "*** YOUR CODE HERE ***"
          return [review_rating(x) for x in restaurant['reviews']]
    #+end_src 
    - ~[review_rating(x) for x in restaurant['reviews']]~ 
** Phase 2: Unsupervised Learning
*** Problem 3
    #+begin_src python :results output
      def find_closest(location, centroids):
          """Return the centroid in centroids that is closest to location.
          If multiple centroids are equally close, return the first one.

          >>> find_closest([3.0, 4.0], [[0.0, 0.0], [2.0, 3.0], [4.0, 3.0], [5.0, 5.0]])
          [2.0, 3.0]
          """
          # BEGIN Question 3
          "*** YOUR CODE HERE ***"
          return min(centroids, key = lambdax: distance(location, x))
    #+end_src 
    - ~return min(centroids, key = lambdax: distance(location, x))~ 

*** Problem 4
    #+begin_src python :results output
      def group_by_first(pairs):
          """Return a list of lists that relates each unique key in the [key, value]
          pairs to a list of all values that appear paired with that key.

          Arguments:
          pairs -- a sequence of pairs

          >>> example = [ [1, 2], [3, 2], [2, 4], [1, 3], [3, 1], [1, 2] ]
          >>> group_by_first(example)  # Values from pairs that start with 1, 3, and 2 respectively
          [[2, 3, 2], [2, 1], [4]]
          """
          keys = []
          for key, _ in pairs:
              if key not in keys:
                  keys.append(key)
          return [[y for x, y in pairs if x == key] for key in keys]
      def group_by_centroid(restaurants, centroids):
          """Return a list of clusters, where each cluster contains all restaurants
          nearest to a corresponding centroid in centroids. Each item in
          restaurants should appear once in the result, along with the other
          restaurants closest to the same centroid.
          """
          # BEGIN Question 4
          "*** YOUR CODE HERE ***"
          pairs = [[find_closest(restaurant_location(x), centroids), x] for x in restaurants]
          return group_by_first(pairs) 
    #+end_src 
    - *List of lists*: from external to internal
      - ~[[y for x, y in pairs if x == key] for key in keys]~
      - ~[[find_closest(restaurant_location(x), centroids), x] for x in restaurants]~ 
*** Problem 6 
    #+begin_src python :results output
      def k_means(restaurants, k, max_updates=100):
          """Use k-means to group restaurants by location into k clusters."""
          assert len(restaurants) >= k, 'Not enough restaurants to cluster'
          old_centroids, n = [], 0

          # Select initial centroids randomly by choosing k different restaurants
          centroids = [restaurant_location(r) for r in sample(restaurants, k)]

          while old_centroids != centroids and n < max_updates:
              old_centroids = centroids
              clusters = group_by_centroid(restaurants, centroids)
              centroids = [find_centroid(x) for x in clusters]
              # BEGIN Question 6
              "*** YOUR CODE HERE ***"
              # END Question 6
              n += 1
          return centroids
    #+end_src 
    - K-means procedure: initial centroids --> cluster restaurants --> find and update centroids --> ...
    - ~centroids = [find_centroid(x) for x in clusters]~ 
** Phase 3: Supervised Learning
*** Problem 7
    #+begin_src python :results output
      def find_predictor(user, restaurants, feature_fn):
          """Return a rating predictor (a function from restaurants to ratings),
          for a user by performing least-squares linear regression using feature_fn
          on the items in restaurants. Also, return the R^2 value of this model.

          Arguments:
          user -- A user
          restaurants -- A sequence of restaurants
          feature_fn -- A function that takes a restaurant and returns a number
          """
          xs = [feature_fn(r) for r in restaurants]
          ys = [user_rating(user, restaurant_name(r)) for r in restaurants]
          Sxx = sum([(x - mean(xs)) ** 2 for x in xs])
          Syy = sum([(y - mean(ys)) ** 2 for y in ys])
          Sxy = sum([(x - mean(xs)) * (y - mean(ys)) for x, y in zip(xs, ys)])
          b = Sxy / Sxx
          a = mean(ys) - b * mean(xs)
          r_squared = Sxy ** 2 / (Sxx * Syy)
          # BEGIN Question 7
          "*** YOUR CODE HERE ***"
          # END Question 7

          def predictor(restaurant):
              return b * feature_fn(restaurant) + a

          return predictor, r_squared
    #+end_src 
    - ~sum([(x - mean(xs)) * (y - mean(ys)) for x, y in zip(xs, ys)])~, not ~sum([(x - mean(xs)) * (y - mean(ys)) for x, y in xs, ys])~
    - ~restaurant~ in ~def predictor(restaurant)~ is the one *to be predicted*  
*** Problem 8
    #+begin_src python :results output
      def best_predictor(user, restaurants, feature_fns):
          """Find the feature within feature_fns that gives the highest R^2 value
          for predicting ratings by the user; return a predictor using that feature.

          Arguments:
          user -- A user
          restaurants -- A list of restaurants
          feature_fns -- A sequence of functions that each takes a restaurant
          """
          reviewed = user_reviewed_restaurants(user, restaurants)
          predictors = [list(find_predictor(user, reviewed, x)) for x in feature_fns]
          return max(predictors, key = lambda x: x[1])[0]
          # BEGIN Question 8
          "*** YOUR CODE HERE ***"
    #+end_src 
    - ~reviewed = user_reviewed_restaurants(user, restaurants)~ 
    - ~predictors = [list(find_predictor(user, reviewed, x)) for x in feature_fns]~
    - ~max(predictors, key = lambda x: x[1])[0]~ 
*** Problem 9
    #+begin_src python :results output
      def rate_all(user, restaurants, feature_fns):
          """Return the predicted ratings of restaurants by user using the best
          predictor based on a function from feature_fns.

          Arguments:
          user -- A user
          restaurants -- A list of restaurants
          feature_fns -- A sequence of feature functions
          """
          predictor = best_predictor(user, ALL_RESTAURANTS, feature_fns)
          reviewed = user_reviewed_restaurants(user, restaurants)
          # BEGIN Question 9
          "*** YOUR CODE HERE ***"
          to_rate = [x for x in restaurants if x not in reviewed]
          dict1 = {restaurant_name(x): predictor(x) for x in to_rate}
          dict2 = {restaurant_name(x): user_rating(user, restaurant_name(x)) for x in reviewed}
          return {**dict1, **dict2}
    #+end_src 
    - ~reviewed = user_reviewed_restaurants(user, restaurants)~ 
    - To merge 2 dicts: ~{**dict1, **dict2}~
    - ~dict1 = {restaurant_name(x): predictor(x) for x in to_rate}~ and ~dict2 = {restaurant_name(x): user_rating(user, restaurant_name(x)) for x in reviewed}~ 

*** Question:                                                     :QUESTIONS:
    1. 主要是Phase 3的监督学习理论原理以及对应代码逻辑盘清楚(arguments, func abs and data abs)
** Predicting your own ratings                                  :OUTSTANDING:
* Project 3: Ants Vs. SomeBees 
** Phase 1: Basic gameplay
*** Problem 2
    #+begin_src python :results output
      def __init__(self, name, exit=None):
          """Create a Place with the given NAME and EXIT.

          name -- A string; the name of this Place.
          exit -- The Place reached by exiting this Place (may be None).
          """
          self.name = name
          self.exit = exit
          self.bees = []        # A list of Bees
          self.ant = None       # An Ant
          self.entrance = None  # A Place
          # Phase 1: Add an entrance to the exit
          # BEGIN Problem 2
          "*** YOUR CODE HERE ***"
          if exit:
              exit.entrance = self
          # END Problem 2
    #+end_src 
*** Problem 3 & 4
    #+begin_src python :results output
      class ThrowerAnt(Ant):
          """ThrowerAnt throws a leaf each turn at the nearest Bee in its range."""

          name = 'Thrower'
          implemented = True
          damage = 1
          # ADD/OVERRIDE CLASS ATTRIBUTES HERE
          food_cost = 3
          min_range = 0
          max_range = float('inf')
          def nearest_bee(self, hive):
              """Return the nearest Bee in a Place that is not the HIVE, connected to
              the ThrowerAnt's Place by following entrances.

              This method returns None if there is no such Bee (or none in range).
              """
              # BEGIN Problem 3 and 4
              place = self.place
              n = 0
              while place != hive:
                  if place.bees and n >= self.min_range and n <= self.max_range:
                      return random_or_none(place.bees)
                  n += 1
                  place = place.entrance
              return None
              # END Problem 3 and 4

          def throw_at(self, target):
              """Throw a leaf at the TARGET Bee, reducing its armor."""
              if target is not None:
                  target.reduce_armor(self.damage)

          def action(self, colony):
              """Throw a leaf at the nearest Bee in range."""
              self.throw_at(self.nearest_bee(colony.hive))

      def random_or_none(s):
          """Return a random element of sequence S, or return None if S is empty."""
          if s:
              return random.choice(s)

      ##############
      # Extensions #
      ##############

      class ShortThrower(ThrowerAnt):
          """A ThrowerAnt that only throws leaves at Bees at most 3 places away."""

          name = 'Short'
          # OVERRIDE CLASS ATTRIBUTES HERE
          # BEGIN Problem 4
          implemented = True   # Change to True to view in the GUI
          food_cost = 2
          min_range = 0
          max_range = 3
          # END Problem 4

      class LongThrower(ThrowerAnt):
          """A ThrowerAnt that only throws leaves at Bees at least 5 places away."""

          name = 'Long'
          # OVERRIDE CLASS ATTRIBUTES HERE
          # BEGIN Problem 4
          implemented = True   # Change to True to view in the GUI
          food_cost = 2
          min_range = 5
          max_range = float('inf')
    #+end_src 

** Phase 2: Ants Attack
*** Problem 5
    #+begin_src python :results output
      class FireAnt(Ant):
          """FireAnt cooks any Bee in its Place when it expires."""

          name = 'Fire'
          damage = 3
          # OVERRIDE CLASS ATTRIBUTES HERE
          # BEGIN Problem 5
          food_cost = 5
          implemented = True   # Change to True to view in the GUI
          # END Problem 5

          def reduce_armor(self, amount):
              """Reduce armor by AMOUNT, and remove the FireAnt from its place if it
              has no armor remaining. If the FireAnt dies, damage each of the bees in
              the current place.
              """
              # BEGIN Problem 5 
              self.armor = (self.armor - amount) if (self.armor - amount) > 0 else 0
              if not self.armor:
                  for bee in self.place.bees[:]:
                      bee.reduce_armor(self.damage)
                  self.place.remove_insect(self)
              "*** YOUR CODE HERE ***"
    #+end_src 
    - ~for bee in self.place.bees[:]:~ 
*** Problem 6
    #+begin_src python :results output
      class HungryAnt(Ant):
          """HungryAnt will take three turns to digest a Bee in its place.
          While digesting, the HungryAnt can't eat another Bee.
          """
          name = 'Hungry'
          # OVERRIDE CLASS ATTRIBUTES HERE
          food_cost = 4
          # BEGIN Problem 6
          time_to_digest = 3
          implemented = True   # Change to True to view in the GUI
          # END Problem 6

          def __init__(self, armor=1):
              # BEGIN Problem 6
              "*** YOUR CODE HERE ***"
              Ant.__init__(self, armor)
              self.digesting = 0
              # END Problem 6

          def eat_bee(self, bee):
              # BEGIN Problem 6
              "*** YOUR CODE HERE ***"
              bee.reduce_armor(bee.armor)
              self.digesting = self.time_to_digest
              # END Problem 6

          def action(self, colony):
              # BEGIN Problem 6
              "*** YOUR CODE HERE ***"
              if self.digesting == 0:
                  bee = random_or_none(self.place.bees)
                  if bee:
                      self.eat_bee(bee)
              else:
                  self.digesting -= 1
    #+end_src 
    - ~bee.reduce_armor(bee.armor)~

*** Problem 7
    #+begin_src python :results output
      ... (class Bee)
          def blocked(self):
              """Return True if this Bee cannot advance to the next Place."""
              # Phase 4: Special handling for NinjaAnt
              # BEGIN Problem 7
              return self.place.ant is not None and self.place.ant.blocks_path
              # END Problem 7
      ...

      class NinjaAnt(Ant):
          """NinjaAnt does not block the path and damages all bees in its place."""

          name = 'Ninja'
          damage = 1
          # OVERRIDE CLASS ATTRIBUTES HERE
          food_cost = 5
          # BEGIN Problem 7
          implemented = True   # Change to True to view in the GUI
          blocks_path = False
          # END Problem 7

          def action(self, colony):
              # BEGIN Problem 7
              for bee in self.place.bees[:]:
                  bee.reduce_armor(self.damage)
              "*** YOUR CODE HERE ***"
    #+end_src 

** Phase 3: But They Also Protect
*** Problem 9
    #+begin_src python :results output
      ... (class Place)
          def add_insect(self, insect):
              """Add an Insect to this Place.

              There can be at most one Ant in a Place, unless exactly one of them is
              a container ant (Problem 9), in which case there can be two. If add_insect
              tries to add more Ants than is allowed, an assertion error is raised.

              There can be any number of Bees in a Place.
              """
              """ sol1 (my sol)"""
              if insect.is_ant:
                  if self.ant is None:
                      self.ant = insect
                  elif insect.is_container and insect.can_contain(self.ant):
                      insect.contain_ant(self.ant)
                      self.ant = insect
                  elif self.ant.is_container and self.ant.can_contain(insect):
                      self.ant.contain_ant(insect)
                  else:
                      # BEGIN Problem 9
                      assert self.ant is None, 'Two ants in {0}'.format(self)
                      # END Problem 9
              else:
                  self.bees.append(insect)
              insect.place = self

              """ sol2 """
              # if insect.is_ant:
              #     if self.ant is not None:
              #         if self.ant.is_container and self.ant.can_contain(insect):
              #             self.ant.contain_ant(insect)
              #             insect.place = self
              #             return
              #         elif insect.is_container and insect.can_contain(self.ant):
              #             insect.contain_ant(self.ant)
              #             self.ant = insect
              #             insect.place = self
              #             return
              #     else:
              #         assert self.ant is None, 'Two ants in {0}'.format(self)
              #         self.ant = insect
              # else:
              #     self.bees.append(insect)
              # insect.place
      ...

      class BodyguardAnt(Ant):
          """BodyguardAnt provides protection to other Ants."""

          name = 'Bodyguard'
          # OVERRIDE CLASS ATTRIBUTES HERE
          food_cost = 4
          # BEGIN Problem 9
          implemented = True   # Change to True to view in the GUI
          is_container = True
          # END Problem 9

          def __init__(self, armor=2):
              Ant.__init__(self, armor)
              self.contained_ant = None  # The Ant hidden in this bodyguard

          def can_contain(self, other):
              # BEGIN Problem 9
              "*** YOUR CODE HERE ***"
              return self.contained_ant is None and not other.is_container
              # END Problem 9

          def contain_ant(self, ant):
              # BEGIN Problem 9
              "*** YOUR CODE HERE ***"
              self.contained_ant = ant
              # END Problem 9

          def action(self, colony):
              # BEGIN Problem 9
              "*** YOUR CODE HERE ***"
              if self.contained_ant:
                  self.contained_ant.action(colony)
    #+end_src 
*** Problem 10
    #+begin_src python :results output
      class TankAnt(BodyguardAnt):
          """TankAnt provides both offensive and defensive capabilities."""

          name = 'Tank'
          damage = 1
          # OVERRIDE CLASS ATTRIBUTES HERE
          food_cost = 6
          # BEGIN Problem 10
          implemented = True   # Change to True to view in the GUI
          is_container = True
          # END Problem 10

          def action(self, colony):
              # BEGIN Problem 10
              "*** YOUR CODE HERE ***"
              for bee in self.place.bees[:]:
                  bee.reduce_armor(self.damage)
              if self.contained_ant:
                  self.contained_ant.action(colony)
    #+end_src 

** Phase 4: Water and Might
*** Problem 11
    #+begin_src python :results output
      class Water(Place):
          """Water is a place that can only hold watersafe insects."""

          def add_insect(self, insect):
              """Add an Insect to this place. If the insect is not watersafe, reduce
              its armor to 0."""
              # BEGIN Problem 11
              Place.add_insect(self, insect)
              for bee in self.bees[:]:
                  if not bee.is_watersafe:
                      bee.reduce_armor(bee.armor)
              if self.ant:
                  if not self.ant.is_watersafe:
                      self.ant.reduce_armor(self.ant.armor)
              "*** YOUR CODE HERE ***"
    #+end_src 

*** Problem 13
    #+begin_src python :results output
      ... (class Place)
          def remove_insect(self, insect):
              """Remove an INSECT from this Place.

              A target Ant may either be directly in the Place, or be contained by a
              container Ant at this place. The true QueenAnt may not be removed. If
              remove_insect tries to remove an Ant that is not anywhere in this
              Place, an AssertionError is raised.
              A Bee is just removed from the list of Bees.
              """
              if insect.is_ant:
                  # Special handling for QueenAnt
                  # BEGIN Problem 13
                  "*** YOUR CODE HERE ***"
                  if hasattr(insect, 'is_queen'):
                      if insect.is_queen:
                          return
                  # END Problem 13

                  # Special handling for container ants
                  if self.ant is insect:
                      # Bodyguard was removed. Contained ant should remain in the game
                      if hasattr(self.ant, 'is_container') and self.ant.is_container:
                          self.ant = self.ant.contained_ant
                      else:
                          self.ant = None
                  else:
                      # Contained ant was removed. Bodyguard should remain
                      if hasattr(self.ant, 'is_container') and self.ant.is_container \
                              and self.ant.contained_ant is insect:
                          self.ant.contained_ant = None
                      else:
                          assert False, '{0} is not in {1}'.format(insect, self)
              else:
                  self.bees.remove(insect)

              insect.place = None
      ...

      class QueenAnt(ScubaThrower):  # You should change this line
      # END Problem 13
          """The Queen of the colony. The game is over if a bee enters her place."""

          name = 'Queen'
          # OVERRIDE CLASS ATTRIBUTES HERE
          food_cost = 7
          # BEGIN Problem 13
          implemented = True   # Change to True to view in the GUI
          is_queen = True
          is_doubled = False
          # END Problem 13

          def __init__(self, armor=1):
              # BEGIN Problem 13
              Ant.__init__(self, armor)
              self.is_queen = QueenAnt.is_queen
              QueenAnt.is_queen = False
              self.doubled_ants = []

              # if not QueenAnt.is_queen:
              #     QueenAnt.is_queen = True
              #     self.is_queen = True
              # else:
              #     self.is_queen = False

              "*** YOUR CODE HERE ***"
              # END Problem 13

          def action(self, colony):
              """A queen ant throws a leaf, but also doubles the damage of ants
              in her tunnel.

              Impostor queens do only one thing: reduce their own armor to 0.
              """
              # BEGIN Problem 13
              "*** YOUR CODE HERE ***"
              if self.is_queen:
                  # ant = self.place.ant
                  # if isinstance(ant, TankAnt):
                  #     TankAnt.action(ant, colony)
                  # if isinstance(ant, BodyguardAnt):
                  #     BodyguardAnt.action(ant, colony)
                  # if isinstance(ant, QueenAnt):
                  #     ScubaThrower.action(self, colony)
                  ScubaThrower.action(self, colony)
                  place = self.place
                  damage_tuple = (ThrowerAnt, ShortThrower, LongThrower, FireAnt, NinjaAnt, ScubaThrower, TankAnt)
                  while place.exit is not None:
                      exit_ant = place.exit.ant
                      if exit_ant is not None:
                          if isinstance(exit_ant, damage_tuple) and exit_ant not in self.doubled_ants:
                              exit_ant.damage *= 2
                              self.doubled_ants.append(exit_ant)
                          if isinstance(exit_ant, (TankAnt, BodyguardAnt)):
                              if isinstance(exit_ant.contained_ant, damage_tuple) and exit_ant.contained_ant not in self.doubled_ants:
                                  exit_ant.contained_ant.damage *= 2
                                  self.doubled_ants.append(exit_ant.contained_ant)
                      place = place.exit
              else:
                  self.reduce_armor(self.armor)

              # END Problem 13

          def reduce_armor(self, amount):
              """Reduce armor by AMOUNT, and if the True QueenAnt has no armor
              remaining, signal the end of the game.
              """
              # BEGIN Problem 13
              "*** YOUR CODE HERE ***"
              self.armor -= amount
              if self.armor <= 0:
                  if self.is_queen:
                      bees_win()
                  else:
                      self.place.remove_insect(self)
    #+end_src 

** Extra Credit
** Optional Problem
   
